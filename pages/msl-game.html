<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MSL Study Lab & Games – SMCM MSL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="../assets/css/styles.css" />
  <link rel="icon" type="image/png" href="../assets/img/logo-1.png" />

  <!-- Page-specific layout tweaks -->
  <style>
    body.game-page {
      background: radial-gradient(circle at top, #111827, #020617);
      color: #f9fafb;
    }

    .game-page .section {
      padding-top: 3rem;
      padding-bottom: 3rem;
    }

    .game-page .section .inner {
      max-width: 1160px;
    }

    .game-page h1,
    .game-page h2,
    .game-page h3 {
      color: #f9fafb;
    }

    .game-layout {
      display: flex;
      flex-direction: column;
      gap: 2.6rem;
    }

    @media (min-width: 900px) {
      .game-layout {
        flex-direction: row;
        align-items: flex-start;
      }
      .game-layout-main {
        flex: 3;
      }
      .game-layout-side {
        flex: 2;
      }
    }

    .game-column {
      display: flex;
      flex-direction: column;
      gap: 1.8rem;
    }

    .game-card-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    .game-card-title span.label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      opacity: 0.8;
    }

    .game-card-title span.label.study {
      color: #4ade80;
    }
    .game-card-title span.label.game {
      color: #60a5fa;
    }

    .game-page .card.plain-card {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.8);
      padding: 1.5rem 1.35rem 1.6rem;
      transition: transform 160ms ease, box-shadow 160ms ease, border-color 160ms ease;
    }

    .game-page .card.plain-card:hover,
    .game-page .card.plain-card:focus-within {
      transform: translateY(-3px);
      border-color: rgba(96, 165, 250, 0.5);
      box-shadow: 0 22px 50px rgba(8, 47, 73, 0.5);
    }

    .game-page .small,
    .game-page .section-body,
    .game-page p {
      color: #e5e7eb;
    }

    /* Canvas containers */
    .canvas-shell {
      background: linear-gradient(145deg, rgba(2, 6, 23, 0.94), rgba(15, 23, 42, 0.9));
      border-radius: 0.9rem;
      padding: 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.45);
      text-align: center;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }
    .canvas-shell.expanded {
      padding: 1rem;
    }
    .canvas-shell canvas {
      background: #020617;
      display: block;
      margin: 0 auto;
      max-width: 100%;
      height: auto;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .controls-text {
      font-size: 0.8rem;
      opacity: 0.9;
      margin-top: 0.35rem;
    }

    .game-control-row {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
      margin: 0.65rem 0 0.35rem;
    }

    .control-label {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.85rem;
      color: #e5e7eb;
    }

    .control-label select {
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      border-radius: 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      padding: 0.4rem 0.55rem;
    }

    .inline-toggle {
      flex-direction: row;
      align-items: center;
      gap: 0.4rem;
    }

    .game-page .btn.small {
      padding: 0.4rem 0.75rem;
      font-size: 0.85rem;
    }

    .game-page .btn.btn-ghost {
      background: rgba(255, 255, 255, 0.06);
      color: #e5e7eb;
    }

    .game-page .btn.btn-ghost:hover {
      background: rgba(255, 255, 255, 0.12);
    }

    /* Quiz styles */
    #quiz-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    #quiz-question {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
    #quiz-options button {
      display: block;
      width: 100%;
      text-align: left;
      border-radius: 0.5rem;
      padding: 0.5rem 0.75rem;
      margin-bottom: 0.4rem;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      cursor: pointer;
      font-size: 0.9rem;
    }
    #quiz-options button:hover {
      background: rgba(37, 99, 235, 0.2);
    }
    #quiz-feedback {
      font-size: 0.85rem;
      min-height: 1.2em;
    }

    .quiz-block {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .quiz-options button {
      display: block;
      width: 100%;
      text-align: left;
      border-radius: 0.5rem;
      padding: 0.5rem 0.75rem;
      margin-bottom: 0.35rem;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .quiz-options button:hover {
      background: rgba(37, 99, 235, 0.2);
    }

    .quiz-options button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .info-box {
      background: rgba(30, 41, 59, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 0.75rem;
      padding: 0.75rem 0.85rem;
      margin: 0.35rem 0;
    }

    /* Hangman */
    #hangman-word {
      font-size: 1.25rem;
      letter-spacing: 0.25em;
      text-align: center;
      margin-bottom: 0.5rem;
    }
    #hangman-letters button {
      margin: 0.1rem;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      font-size: 0.75rem;
      cursor: pointer;
    }
    #hangman-letters button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    #hangman-status {
      font-size: 0.85rem;
      margin-top: 0.4rem;
      text-align: center;
      min-height: 1.2em;
    }

    .bar-fill.energy {
      background: #22c55e;
    }
    .bar-fill.mood {
      background: #facc15;
    }
    .bar-fill.focus {
      background: #38bdf8;
    }

    .reaction-shell {
      border: 1px dashed rgba(148, 163, 184, 0.5);
      border-radius: 0.75rem;
      padding: 0.75rem;
      background: rgba(15, 23, 42, 0.45);
    }

    .reaction-controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin: 0.5rem 0;
    }

    /* YouTube embed ratio */
    .video-shell {
      position: relative;
      padding-bottom: 56.25%;
      height: 0;
      overflow: hidden;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.6);
    }
    .video-shell iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
    }
  </style>
</head>

<body class="game-page" data-page="games">
  <header id="siteHeader" class="site-header">
    <div id="site-nav"></div>
  </header>

  <main>
    <!-- HEADER -->
    <section class="section">
      <div class="inner">
        <div class="section-header center">
          <p class="eyebrow">Practice, Play, Repeat</p>
          <h1>MSL Study Lab & Mini-Games</h1>
          <p class="section-body">
            Use this space to quiz yourself on legislative basics, watch a short explainer on how bills
            become law, and then unwind with low-stakes mini-games. Desktop is recommended for the games
            (keyboard controls), but the video and quiz work on mobile too.
          </p>
        </div>

        <div class="game-layout">
          <!-- LEFT: STUDY COLUMN -->
          <div class="game-layout-main game-column">
            <!-- Quiz -->
            <article class="card plain-card">
              <div class="game-card-title">
                <h2>MSL Quick Quiz</h2>
                <span class="label study">Study</span>
              </div>
              <p class="small">
                Short questions based on things you’ll see in MSL: committees, bills, chambers, and procedure.
                Great to run through before a meeting or session.
              </p>
              <div id="quiz-container">
                <div id="quiz-question"></div>
                <div id="quiz-options"></div>
                <div id="quiz-feedback" class="small"></div>
                <button id="quiz-next" class="btn btn-primary small" style="margin-top:0.5rem;">
                  Next Question
                </button>
                <p id="quiz-score" class="small" style="margin-top:0.5rem;"></p>
              </div>
            </article>

            <article class="card plain-card">
              <div class="game-card-title">
                <h2>Quick Civics Quiz</h2>
                <span class="label study">Quiz</span>
              </div>
              <p class="small">
                Ten rapid-fire civics checks covering rights, branches, and how laws move. Each run shuffles the questions.
                See if you can beat your best score.
              </p>
              <div class="info-box small">
                <strong>How it works:</strong> Pick the best answer, see immediate feedback, and hit restart to reshuffle.
                Scores and your best run stay on this device.
              </div>
              <div class="quiz-block" id="civics-quiz">
                <div id="civics-question" class="quiz-question"></div>
                <div id="civics-options" class="quiz-options"></div>
                <div id="civics-feedback" class="small"></div>
                <div class="quiz-meta small" style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:0.5rem;">
                  <span id="civics-progress"></span>
                  <span id="civics-best"></span>
                </div>
                <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.25rem;">
                  <button id="civics-next" class="btn btn-primary small">Next</button>
                  <button id="civics-restart" class="btn btn-ghost small">Restart</button>
                </div>
              </div>
            </article>

            <!-- CrashCourse video -->
            <article class="card plain-card">
              <div class="game-card-title">
                <h2>How a Bill Becomes Law (Crash Course)</h2>
                <span class="label study">Watch</span>
              </div>
              <p class="small">
                A quick visual run-through of committee, floor, and conference stages. Different level than MSL,
                same core logic of how ideas move through a legislature.
              </p>
              <div class="video-shell">
                <!-- Crash Course Government & Politics: How a Bill Becomes a Law -->
                <iframe
                  src="https://www.youtube.com/embed/66f4-NKEYz4"
                  title="How a Bill Becomes a Law – Crash Course Government and Politics"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                  allowfullscreen
                ></iframe>
              </div>
            </article>
          </div>

          <!-- RIGHT: GAMES COLUMN -->
          <div class="game-layout-side game-column">
            <!-- Snake -->
            <article class="card plain-card">
              <div class="game-card-title">
                <h2>Chamber Snake</h2>
                <span class="label game">Game</span>
              </div>
              <p class="small">
                Classic snake-style game. Collect “bills” (squares) and avoid running into yourself (or the AI opponent).
                <strong>Controls:</strong> W, A, S, D keys on desktop. On mobile, this one is better viewed than played.
              </p>
              <div class="game-control-row">
                <label class="control-label">
                  Difficulty
                  <select id="snakeDifficulty">
                    <option value="easy">Easy</option>
                    <option value="medium" selected>Medium</option>
                    <option value="hard">Hard</option>
                  </select>
                </label>
                <label class="control-label inline-toggle">
                  <input type="checkbox" id="snakeAiToggle" checked />
                  <span>AI Opponent: On</span>
                </label>
                <button id="snakeRestart" class="btn btn-ghost small" type="button">Restart</button>
              </div>
              <div class="canvas-shell expanded">
                <canvas id="snakeCanvas" width="640" height="480"></canvas>
              </div>
              <p id="snakeStatus" class="controls-text">Bills passed: 0 · Opponent: ready</p>
              <p class="controls-text">Tiny sparkle pops when bills are eaten. Tip: aim for 12+ “bills” in one run.</p>
            </article>

            <!-- Runner -->
            <article class="card plain-card">
              <div class="game-card-title">
                <h2>Floor Runner</h2>
                <span class="label game">Game</span>
              </div>
              <p class="small">
                Dodge procedural triangles, avoid gaps, and hit “boost blocks” to pick up speed.
                <strong>Controls:</strong> Spacebar or tap/click inside the game box to jump.
              </p>
              <p class="small" style="opacity:0.8;">Energy: Fast reflexes—best when you want a quick adrenaline spike.</p>
              <div class="game-control-row">
                <button id="runner-start" class="btn btn-primary small" type="button">Start / Restart</button>
                <span class="controls-text">Jump only when your feet are on the line. Hold for a little extra lift.</span>
              </div>
              <div class="canvas-shell expanded">
                <canvas id="runnerCanvas" width="720" height="960"></canvas>
              </div>
              <p class="controls-text">
                Score = seconds survived. Clear rails and outlined gaps keep you honest.
              </p>
              <p id="runner-best" class="small" style="margin-top:0.35rem;"></p>
              <div id="runner-leaderboard" class="small" style="margin-top:0.25rem;"></div>
            </article>

            <!-- Hangman -->
            <article class="card plain-card">
              <div class="game-card-title">
                <h2>Legislative Hangman</h2>
                <span class="label game">Game</span>
              </div>
              <p class="small">
                Guess MSL-related words before your attempts run out. All terms are drawn from things you’ll hear
                in meetings, bylaws, or statewide sessions.
              </p>
              <p class="small" style="opacity:0.8;">Vibe: Low-stress letters game for when you need a breather.</p>
              <div class="info-box small">
                <strong>How to play:</strong> Tap or click letters to reveal the word. You get seven misses—keep an ear out for
                familiar MSL terms.
              </div>
              <div id="hangman-word">_ _ _ _</div>
              <div id="hangman-letters"></div>
              <div id="hangman-status" class="small"></div>
              <button id="hangman-reset" class="btn btn-primary small" style="margin-top:0.5rem;">
                New Word
              </button>
            </article>

            <!-- Reaction time game -->
            <article class="card plain-card">
              <div class="game-card-title">
                <h2>Gavel Reflex Drill</h2>
                <span class="label game">Game</span>
              </div>
              <p class="small">
                The presiding officer calls a vote—react as soon as you see “GO” to log a lightning-fast time.
                Click or press the space bar when the prompt appears.
              </p>
              <p class="small" style="opacity:0.8;">Mode: Quick-fire reflex test with honest feedback.</p>
              <div class="reaction-shell">
                <p id="reactionStatus" class="small">Press “Start round” to begin.</p>
                <div class="reaction-controls">
                  <button id="reactionStart" class="btn btn-primary small">Start round</button>
                  <button id="reactionTap" class="btn btn-ghost small" disabled>Tap when you see “GO”</button>
                </div>
                <p id="reactionResult" class="small"></p>
                <p id="reactionBest" class="small" style="opacity:0.75;"></p>
              </div>
            </article>

          </div>
        </div>
      </div>
    </section>

  </main>

  <footer class="site-footer">
    <div class="inner footer-inner">
      <p>© <span id="year"></span> Maryland Student Legislature – St. Mary’s College of Maryland Chapter.</p>
      <p class="small">
        Student-led, nonpartisan, and rooted in Maryland’s civic life. This site is maintained by the SMCM
        Maryland Student Legislature Chapter and is not an official publication of St. Mary’s College of
        Maryland or the State of Maryland.
      </p>
    </div>
  </footer>

  <script src="../assets/js/script.js"></script>

  <!-- Page-specific JS: all guarded so errors don't break the page -->
  <script src="../assets/js/nav.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      /* ---------- QUIZ ---------- */
      (function () {
        const questionEl = document.getElementById("quiz-question");
        const optionsEl = document.getElementById("quiz-options");
        const feedbackEl = document.getElementById("quiz-feedback");
        const nextBtn = document.getElementById("quiz-next");
        const scoreEl = document.getElementById("quiz-score");

        if (!questionEl || !optionsEl || !feedbackEl || !nextBtn || !scoreEl) return;

        const quiz = [
          {
            q: "In MSL, where does most detailed work on a bill happen first?",
            options: [
              "On the floor during final vote",
              "In committee hearings and markups",
              "In the governor’s office",
              "On social media"
            ],
            correct: 1
          },
          {
            q: "Which phrase best matches what a “sponsor” does?",
            options: [
              "Writes and introduces the bill",
              "Keeps time during speeches",
              "Runs the statewide organization",
              "Counts votes after the session"
            ],
            correct: 0
          },
          {
            q: "A motion to ‘table’ a bill usually means:",
            options: [
              "The bill passes immediately",
              "Debate continues with no speeches",
              "Consideration is paused or set aside",
              "The bill must be rewritten from scratch"
            ],
            correct: 2
          },
          {
            q: "What’s the main role of a committee chair?",
            options: [
              "To write every bill",
              "To enforce rules and manage discussion",
              "To record every vote by hand",
              "To campaign for statewide office"
            ],
            correct: 1
          },
          {
            q: "Why does MSL use parliamentary procedure?",
            options: [
              "To confuse new members",
              "To keep debate fair, orderly, and consistent",
              "Because it’s required by Maryland law",
              "So only officers can speak"
            ],
            correct: 1
          }
        ];

        let index = 0;
        let score = 0;
        let answered = false;

        function renderQuestion() {
          const current = quiz[index];
          answered = false;
          questionEl.textContent = current.q;
          feedbackEl.textContent = "";
          optionsEl.innerHTML = "";
          current.options.forEach((opt, i) => {
            const btn = document.createElement("button");
            btn.textContent = opt;
            btn.addEventListener("click", () => handleAnswer(i));
            optionsEl.appendChild(btn);
          });
          scoreEl.textContent = `Question ${index + 1} of ${quiz.length} · Score: ${score}`;
        }

        function handleAnswer(choice) {
          if (answered) return;
          answered = true;
          const current = quiz[index];
          if (choice === current.correct) {
            score++;
            feedbackEl.textContent = "Correct – you’d survive in committee.";
            feedbackEl.style.color = "#4ade80";
          } else {
            feedbackEl.textContent = "Not quite – check how we do it in MSL.";
            feedbackEl.style.color = "#f97373";
          }
          scoreEl.textContent = `Question ${index + 1} of ${quiz.length} · Score: ${score}`;
        }

        nextBtn.addEventListener("click", () => {
          index++;
          if (index >= quiz.length) {
            feedbackEl.textContent =
              score === quiz.length
                ? "Perfect run. You’re unofficially ‘floor ready’."
                : "Nice work. Run it again later and see if you can get them all.";
            feedbackEl.style.color = "#facc15";
            index = 0;
            score = 0;
          }
          renderQuestion();
        });

        renderQuestion();
      })();

      /* ---------- CIVICS QUIZ (SHUFFLED) ---------- */
      (function () {
        const questionEl = document.getElementById("civics-question");
        const optionsEl = document.getElementById("civics-options");
        const feedbackEl = document.getElementById("civics-feedback");
        const nextBtn = document.getElementById("civics-next");
        const restartBtn = document.getElementById("civics-restart");
        const progressEl = document.getElementById("civics-progress");
        const bestEl = document.getElementById("civics-best");

        if (!questionEl || !optionsEl || !feedbackEl || !nextBtn || !restartBtn || !progressEl || !bestEl) return;

        const STORAGE_KEY = "mslCivicsBest";
        let best = 0;
        try {
          const stored = localStorage.getItem(STORAGE_KEY);
          if (stored) best = parseInt(stored, 10) || 0;
        } catch (e) {}

        const quiz = [
          {
            q: "How many branches of government share power in the United States?",
            options: ["Two", "Three", "Four", "Five"],
            correct: 1,
            detail: "Legislative, Executive, and Judicial branches split responsibilities."
          },
          {
            q: "What do we call the opening statement of the U.S. Constitution?",
            options: ["The Bill of Rights", "The Preamble", "Article I", "The Amendments"],
            correct: 1,
            detail: "The Preamble outlines the purpose of the Constitution."
          },
          {
            q: "Who signs bills into law at the federal level?",
            options: ["The Speaker of the House", "The Senate Majority Leader", "The President", "The Chief Justice"],
            correct: 2,
            detail: "The President can sign or veto bills passed by Congress."
          },
          {
            q: "How many U.S. Senators does each state have?",
            options: ["One", "Two", "Three", "Four"],
            correct: 1,
            detail: "Every state has two Senators regardless of population."
          },
          {
            q: "What term describes the first ten amendments to the Constitution?",
            options: ["Articles", "Federalist Papers", "Bill of Rights", "Declaration"],
            correct: 2,
            detail: "The Bill of Rights protects individual liberties."
          },
          {
            q: "Who is in charge of the executive branch at the state level in Maryland?",
            options: ["House Speaker", "Governor", "Chief Justice", "Lieutenant Governor"],
            correct: 1,
            detail: "The Governor heads Maryland's executive branch."
          },
          {
            q: "What does the judicial branch do?",
            options: ["Writes laws", "Approves Cabinet members", "Interprets laws", "Runs elections"],
            correct: 2,
            detail: "Courts interpret laws and decide if they follow the Constitution."
          },
          {
            q: "Which chamber introduces revenue (tax) bills under the U.S. Constitution?",
            options: ["House of Representatives", "Senate", "Supreme Court", "Cabinet"],
            correct: 0,
            detail: "Revenue bills start in the House of Representatives."
          },
          {
            q: "What is needed for Congress to override a presidential veto?",
            options: ["Simple majority in either chamber", "Two-thirds vote in both chambers", "Unanimous consent", "Decision by the Supreme Court"],
            correct: 1,
            detail: "A two-thirds vote in both chambers overrides a veto."
          },
          {
            q: "Which amendment guarantees freedom of speech?",
            options: ["First", "Second", "Fourth", "Tenth"],
            correct: 0,
            detail: "The First Amendment protects freedoms of speech, press, religion, assembly, and petition."
          },
          {
            q: "What is judicial review?",
            options: ["The President reviewing bills", "Courts deciding constitutionality", "States approving treaties", "Congress confirming judges"],
            correct: 1,
            detail: "Courts can strike down laws that conflict with the Constitution."
          },
          {
            q: "What is a primary responsibility of state legislatures?",
            options: ["Commanding the National Guard", "Negotiating treaties", "Passing state laws and budgets", "Issuing federal passports"],
            correct: 2,
            detail: "State legislatures craft state statutes and approve the budget."
          },
          {
            q: "Which action is an example of checks and balances?",
            options: ["Congressional elections every two years", "The Senate confirming judicial nominees", "State governments creating school districts", "Citizens serving on juries"],
            correct: 1,
            detail: "The Senate’s confirmation role limits executive appointments."
          },
          {
            q: "How long is a term for a member of the U.S. House of Representatives?",
            options: ["Two years", "Four years", "Six years", "Life appointment"],
            correct: 0,
            detail: "Representatives serve two-year terms."
          }
        ];

        let order = [];
        let index = 0;
        let score = 0;
        let answered = false;

        function shuffle(arr) {
          const copy = [...arr];
          for (let i = copy.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [copy[i], copy[j]] = [copy[j], copy[i]];
          }
          return copy;
        }

        function updateBest() {
          if (score > best) {
            best = score;
            try {
              localStorage.setItem(STORAGE_KEY, String(best));
            } catch (e) {}
          }
          bestEl.textContent = `Best on this device: ${best}/${order.length}`;
        }

        function updateProgress() {
          progressEl.textContent = `Question ${Math.min(index + 1, order.length)} of ${order.length} · Score: ${score}`;
        }

        function renderQuestion() {
          answered = false;
          const current = order[index];
          questionEl.textContent = current.q;
          feedbackEl.textContent = "";
          optionsEl.innerHTML = "";
          nextBtn.textContent = index === order.length - 1 ? "Finish" : "Next";

          current.options.forEach((opt, i) => {
            const btn = document.createElement("button");
            btn.textContent = opt;
            btn.addEventListener("click", () => handleAnswer(i, btn));
            optionsEl.appendChild(btn);
          });

          updateProgress();
          bestEl.textContent = `Best on this device: ${best}/${order.length}`;
        }

        function handleAnswer(choice, btn) {
          if (answered) return;
          answered = true;
          const current = order[index];
          const buttons = optionsEl.querySelectorAll("button");
          buttons.forEach((b) => (b.disabled = true));

          if (choice === current.correct) {
            score++;
            feedbackEl.textContent = `Correct! ${current.detail}`;
            feedbackEl.style.color = "#4ade80";
          } else {
            feedbackEl.textContent = `Not quite. Correct answer: ${current.options[current.correct]}. ${current.detail}`;
            feedbackEl.style.color = "#f97373";
          }
          updateProgress();
        }

        function nextQuestion() {
          if (index >= order.length) {
            startQuiz();
            return;
          }
          if (!answered) {
            feedbackEl.textContent = "Choose an answer before moving on.";
            feedbackEl.style.color = "#facc15";
            return;
          }

          index++;
          if (index >= order.length) {
            feedbackEl.textContent = `Finished! You scored ${score}/${order.length}.`;
            feedbackEl.style.color = score === order.length ? "#4ade80" : "#facc15";
            updateBest();
            nextBtn.textContent = "Restart run";
            progressEl.textContent = `Run complete · Score: ${score}`;
            return;
          }

          renderQuestion();
        }

        function startQuiz() {
          order = shuffle(quiz).slice(0, 10);
          index = 0;
          score = 0;
          renderQuestion();
          feedbackEl.style.color = "#e5e7eb";
        }

        nextBtn.addEventListener("click", nextQuestion);
        restartBtn.addEventListener("click", () => {
          startQuiz();
          bestEl.textContent = `Best on this device: ${best}/${order.length}`;
        });

        startQuiz();
      })();

      /* ---------- SNAKE GAME (desktop-focused) ---------- */
      (function () {
        const canvas = document.getElementById("snakeCanvas");
        const difficultySelect = document.getElementById("snakeDifficulty");
        const aiToggle = document.getElementById("snakeAiToggle");
        const statusEl = document.getElementById("snakeStatus");
        const restartBtn = document.getElementById("snakeRestart");
        if (!canvas || !difficultySelect || !aiToggle || !statusEl || !restartBtn) return;

        const ctx = canvas.getContext("2d");
        const cols = 20;
        const rows = 15;
        const cellSize = Math.floor(Math.min(canvas.width / cols, canvas.height / rows));

        // Normalize canvas to exact grid size for crisp edges
        canvas.width = cols * cellSize;
        canvas.height = rows * cellSize;

        const dirs = [
          { x: 0, y: -1 }, // up
          { x: 0, y: 1 }, // down
          { x: -1, y: 0 }, // left
          { x: 1, y: 0 } // right
        ];

        const settings = {
          easy: { playerStep: 150, aiStep: 210, chaseWeight: 0.65, bufferWeight: 1.6, jitter: 0.3 },
          medium: { playerStep: 125, aiStep: 160, chaseWeight: 0.9, bufferWeight: 1.3, jitter: 0.18 },
          hard: { playerStep: 105, aiStep: 115, chaseWeight: 1.15, bufferWeight: 1.1, jitter: 0.1 }
        };

        let snake = [];
        let opponent = [];
        let dir = { x: 0, y: -1 };
        let pendingDir = dir;
        let aiDir = { x: 0, y: 1 };
        let food = null;
        let alive = true;
        let aiAlive = true;
        let aiEnabled = true;
        let aiRespawnAt = 0;
        let score = 0;
        let lastPlayerStep = 0;
        let lastAiStep = 0;
        const particles = [];

        function resetSnake(fullReset = true) {
          snake = [{ x: Math.floor(cols / 2), y: Math.floor(rows / 2) }];
          dir = { x: 0, y: -1 };
          pendingDir = dir;
          opponent = [
            { x: 3, y: 3 },
            { x: 3, y: 4 }
          ];
          aiDir = { x: 0, y: 1 };
          food = null;
          alive = true;
          aiAlive = aiEnabled;
          aiRespawnAt = 0;
          if (fullReset) score = 0;
          spawnFood();
          updateStatus();
        }

        function updateStatus() {
          statusEl.textContent = `Bills passed: ${score} · Opponent: ${!aiEnabled ? "off" : aiAlive ? "active" : "down"}`;
        }

        function spawnFood() {
          const openCells = [];
          for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
              if (!isOccupied({ x, y })) {
                openCells.push({ x, y });
              }
            }
          }
          food = openCells[Math.floor(Math.random() * openCells.length)];
        }

        function isOut(pos) {
          return pos.x < 0 || pos.x >= cols || pos.y < 0 || pos.y >= rows;
        }

        function isOccupied(pos, skipSnakeTail = false, skipOpponentTail = false) {
          const bodyCheck = (body, skipTail) =>
            body.some((seg, idx) => (skipTail && idx === body.length - 1 ? false : seg.x === pos.x && seg.y === pos.y));
          if (bodyCheck(snake, skipSnakeTail)) return true;
          if (bodyCheck(opponent, skipOpponentTail)) return true;
          return false;
        }

        function addParticles(cell) {
          const baseX = cell.x * cellSize + cellSize / 2;
          const baseY = cell.y * cellSize + cellSize / 2;
          for (let i = 0; i < 14; i++) {
            particles.push({
              x: baseX,
              y: baseY,
              vx: (Math.random() - 0.5) * 1.6,
              vy: (Math.random() - 0.5) * 1.6,
              life: 1
            });
          }
        }

        function moveBody(body, direction, otherBody, isPlayer) {
          const head = body[0];
          const next = { x: head.x + direction.x, y: head.y + direction.y };

          if (isOut(next) || isOccupied(next)) {
            return { dead: true };
          }

          body.unshift(next);

          if (food && next.x === food.x && next.y === food.y) {
            if (isPlayer) {
              score++;
              updateStatus();
            }
            addParticles(food);
            spawnFood();
            return { dead: false, ate: true };
          }

          body.pop();
          return { dead: false, ate: false };
        }

        function heuristicScore(next, config) {
          const dist = Math.abs(next.x - food.x) + Math.abs(next.y - food.y);
          const buffer = Math.min(next.x, cols - 1 - next.x, next.y, rows - 1 - next.y);
          return config.chaseWeight * (cols + rows - dist) + config.bufferWeight * buffer;
        }

        function chooseAiDirection(config) {
          if (!food) return aiDir;
          const head = opponent[0];
          const options = dirs
            .map(d => ({
              dir: d,
              next: { x: head.x + d.x, y: head.y + d.y }
            }))
            .filter(opt => !isOut(opt.next) && !isOccupied(opt.next));

          if (!options.length) return aiDir;

          options.forEach(opt => {
            opt.score = heuristicScore(opt.next, config);
            if (opt.dir.x === aiDir.x && opt.dir.y === aiDir.y) {
              opt.score += 1.5; // prefer smooth paths
            }
            opt.score += (Math.random() - 0.5) * config.jitter;
          });

          options.sort((a, b) => b.score - a.score);
          return options[0].dir;
        }

        function drawCell(x, y, color, outline = "rgba(255,255,255,0.12)") {
          ctx.fillStyle = color;
          ctx.strokeStyle = outline;
          ctx.lineWidth = 1.5;
          ctx.fillRect(x * cellSize + 2, y * cellSize + 2, cellSize - 4, cellSize - 4);
          ctx.strokeRect(x * cellSize + 2, y * cellSize + 2, cellSize - 4, cellSize - 4);
        }

        function draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#0b1224";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.strokeStyle = "rgba(255,255,255,0.05)";
          ctx.lineWidth = 1;
          for (let x = 0; x <= cols; x++) {
            ctx.beginPath();
            ctx.moveTo(x * cellSize + 0.5, 0);
            ctx.lineTo(x * cellSize + 0.5, canvas.height);
            ctx.stroke();
          }
          for (let y = 0; y <= rows; y++) {
            ctx.beginPath();
            ctx.moveTo(0, y * cellSize + 0.5);
            ctx.lineTo(canvas.width, y * cellSize + 0.5);
            ctx.stroke();
          }

          if (food) {
            drawCell(food.x, food.y, "#f97316", "rgba(255,255,255,0.18)");
          }

          snake.forEach((seg, idx) => {
            drawCell(seg.x, seg.y, idx === 0 ? "#4ade80" : "#22c55e");
          });

          if (aiEnabled) {
            opponent.forEach((seg, idx) => {
              drawCell(seg.x, seg.y, idx === 0 ? "#a855f7" : "#7c3aed", "rgba(255,255,255,0.25)");
            });
          }

          // particles
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            if (p.life <= 0) {
              particles.splice(i, 1);
              continue;
            }
            ctx.fillStyle = `rgba(250,204,21,${p.life})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
          }

          if (!alive) {
            ctx.fillStyle = "rgba(15,23,42,0.82)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#facc15";
            ctx.font = "16px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("You collided with a chamber wall.", canvas.width / 2, canvas.height / 2 - 8);
            ctx.fillText("Press R or Restart to run again.", canvas.width / 2, canvas.height / 2 + 14);
          }
        }

        function step(timestamp) {
          const mode = settings[difficultySelect.value] || settings.medium;
          if (!lastPlayerStep) {
            lastPlayerStep = timestamp;
            lastAiStep = timestamp;
          }

          if (alive && timestamp - lastPlayerStep >= mode.playerStep) {
            lastPlayerStep = timestamp;
            const result = moveBody(snake, pendingDir, opponent, true);
            if (result.dead) alive = false;
            else dir = pendingDir;
          }

          if (aiEnabled && aiAlive && timestamp - lastAiStep >= mode.aiStep) {
            lastAiStep = timestamp;
            aiDir = chooseAiDirection(mode);
            const aiResult = moveBody(opponent, aiDir, snake, false);
            if (aiResult.dead) {
              aiAlive = false;
              aiRespawnAt = timestamp + 1500;
              updateStatus();
            }
          }

          if (aiEnabled && !aiAlive && aiRespawnAt && timestamp >= aiRespawnAt) {
            opponent = [
              { x: 2, y: rows - 3 },
              { x: 2, y: rows - 2 }
            ];
            aiDir = { x: 1, y: 0 };
            aiAlive = true;
            aiRespawnAt = 0;
            updateStatus();
          }

          draw();
          requestAnimationFrame(step);
        }

        function handleDirectionChange(nextDir) {
          if (!nextDir) return;
          if (
            snake.length > 1 &&
            snake[0].x + nextDir.x === snake[1].x &&
            snake[0].y + nextDir.y === snake[1].y
          ) {
            return;
          }
          pendingDir = nextDir;
        }

        window.addEventListener("keydown", e => {
          const key = e.key.toLowerCase();
          if (key === "r") {
            resetSnake();
            return;
          }
          if (["w", "a", "s", "d"].includes(key)) {
            e.preventDefault();
          }
          if (key === "w") handleDirectionChange({ x: 0, y: -1 });
          if (key === "s") handleDirectionChange({ x: 0, y: 1 });
          if (key === "a") handleDirectionChange({ x: -1, y: 0 });
          if (key === "d") handleDirectionChange({ x: 1, y: 0 });
        });

        restartBtn.addEventListener("click", () => resetSnake());

        aiToggle.addEventListener("change", () => {
          aiEnabled = aiToggle.checked;
          aiToggle.nextElementSibling.textContent = `AI Opponent: ${aiEnabled ? "On" : "Off"}`;
          if (!aiEnabled) {
            opponent = [];
            aiAlive = false;
          } else {
            resetSnake(false);
          }
          updateStatus();
        });

        difficultySelect.addEventListener("change", () => {
          // Soft reset keeps score but re-centers the board for fairness
          resetSnake(false);
        });

        resetSnake();
        requestAnimationFrame(step);
      })();

      /* ---------- RUNNER GAME (with best score & leaderboard) ---------- */
      (function () {
        const canvas = document.getElementById("runnerCanvas");
        const bestScoreEl = document.getElementById("runner-best");
        const leaderboardEl = document.getElementById("runner-leaderboard");
        const startBtn = document.getElementById("runner-start");
        if (!canvas || !bestScoreEl || !leaderboardEl || !startBtn) return;
        const ctx = canvas.getContext("2d");

        const baseWidth = 720;
        const baseHeight = 960;
        canvas.width = baseWidth;
        canvas.height = baseHeight;
        const groundY = Math.floor(baseHeight * 0.78);

        let player, obstacles, boosts, gaps, speed, gravity, jumpVelocity, score, alive, running, startTime, lastGrounded;
        let bestScore = 0;
        let leaderboard = [];
        let frameCount = 0;
        const coyoteMs = 140;
        const STORAGE_KEY = "mslRunnerLeaderboard";

        function loadLeaderboard() {
          try {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
              const parsed = JSON.parse(stored);
              bestScore = parsed.bestScore || 0;
              leaderboard = parsed.entries || [];
            }
          } catch (e) {}
        }

        function saveBestAndLeaderboard() {
          try {
            localStorage.setItem(
              STORAGE_KEY,
              JSON.stringify({ bestScore, entries: leaderboard })
            );
          } catch (e) {}
        }

        function renderLeaderboard() {
          bestScoreEl.textContent = `Best run on this device: ${Math.floor(bestScore)}s`;
          if (!leaderboard.length) {
            leaderboardEl.textContent =
              "Local leaderboard appears here after a 5-minute run. (Stored only on this device.)";
            return;
          }
          const lines = leaderboard.map((entry, idx) => `${idx + 1}. ${entry.tag} – ${Math.floor(entry.score)}s`);
          leaderboardEl.textContent = "Local leaderboard: " + lines.join(" · ");
        }

        function resetRunner(startImmediately = false) {
          player = { x: 64, y: groundY, vy: 0, onGround: true, w: 22, h: 30 };
          obstacles = [];
          boosts = [];
          gaps = [];
          speed = 3.2;
          gravity = 0.45;
          jumpVelocity = -8.5;
          score = 0;
          alive = true;
          running = startImmediately;
          startTime = performance.now();
          frameCount = 0;
          lastGrounded = performance.now();
        }

        function addObstacle() {
          const width = 16 + Math.random() * 14;
          obstacles.push({
            x: canvas.width + 20,
            y: groundY - 18,
            w: width,
            h: 18
          });
        }

        function addBoost() {
          boosts.push({
            x: canvas.width + 80,
            y: groundY - 50,
            size: 14,
            vy: -0.35
          });
        }

        function addGap() {
          const width = 60 + Math.random() * 50;
          gaps.push({ x: canvas.width + 50, w: width });
        }

        function handleGameOver() {
          const runTime = score; // seconds
          if (runTime > bestScore) {
            bestScore = runTime;
          }

          if (runTime >= 300) {
            let initials = prompt(
              "You survived 5 minutes! Enter a 3-letter tag for the local leaderboard:",
              "MSL"
            );
            if (initials) {
              const tag = initials.toUpperCase().slice(0, 3);
              leaderboard.push({ tag, score: runTime, date: new Date().toISOString() });
              leaderboard.sort((a, b) => b.score - a.score);
              leaderboard = leaderboard.slice(0, 10);
            }
          }

          saveBestAndLeaderboard();
          renderLeaderboard();
        }

        function endRun() {
          if (!alive) return;
          alive = false;
          running = false;
          handleGameOver();
        }

        function updateRunner() {
          if (!alive || !running) return;

          frameCount++;
          const elapsedSec = (performance.now() - startTime) / 1000;
          score = elapsedSec;

          if (frameCount % 100 === 0) addObstacle();
          if (frameCount % 240 === 0) addBoost();
          if (frameCount % 180 === 0) addGap();

          player.vy += gravity;
          player.y += player.vy;

          if (player.y >= groundY) {
            player.y = groundY;
            player.vy = 0;
            player.onGround = true;
            lastGrounded = performance.now();
          } else {
            player.onGround = false;
          }

          obstacles.forEach(o => (o.x -= speed));
          obstacles = obstacles.filter(o => o.x + o.w > -20);

          boosts.forEach(b => {
            b.x -= speed * 0.95;
            b.y += b.vy;
          });
          boosts = boosts.filter(b => b.x + b.size > -20);

          gaps.forEach(g => (g.x -= speed));
          gaps = gaps.filter(g => g.x + g.w > -20);

          for (const o of obstacles) {
            const withinX = player.x + player.w / 2 > o.x && player.x - player.w / 2 < o.x + o.w;
            const withinY = player.y >= o.y && player.y <= o.y + o.h + 6;
            if (withinX && withinY) {
              endRun();
              return;
            }
          }

          for (const g of gaps) {
            if (player.x > g.x && player.x < g.x + g.w && player.y >= groundY) {
              endRun();
              return;
            }
          }

          boosts.forEach(b => {
            const dx = player.x - (b.x + b.size / 2);
            const dy = player.y - (b.y + b.size / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 20) {
              speed = 4.6;
              jumpVelocity = -9.5;
              setTimeout(() => {
                speed = 3.2;
                jumpVelocity = -8.5;
              }, 4200);
              b.x = -999;
            }
          });
        }

        function drawRunner() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
          gradient.addColorStop(0, "#0b1224");
          gradient.addColorStop(1, "#020617");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // ground rails
          ctx.strokeStyle = "rgba(148,163,184,0.75)";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(0, groundY + 10);
          ctx.lineTo(canvas.width, groundY + 10);
          ctx.stroke();
          ctx.strokeStyle = "rgba(59,130,246,0.35)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, groundY + 14);
          ctx.lineTo(canvas.width, groundY + 14);
          ctx.stroke();

          // gaps (with outlines)
          ctx.fillStyle = "#0b1224";
          ctx.strokeStyle = "rgba(248,113,113,0.5)";
          gaps.forEach(g => {
            ctx.fillRect(g.x, groundY + 2, g.w, canvas.height - groundY);
            ctx.strokeRect(g.x, groundY + 2, g.w, 18);
          });

          // player
          ctx.fillStyle = "#38bdf8";
          ctx.strokeStyle = "rgba(255,255,255,0.4)";
          ctx.lineWidth = 2;
          ctx.fillRect(player.x - player.w / 2, player.y - player.h, player.w, player.h);
          ctx.strokeRect(player.x - player.w / 2, player.y - player.h, player.w, player.h);

          // obstacles (triangles with outlines)
          obstacles.forEach(o => {
            ctx.fillStyle = "#f97316";
            ctx.strokeStyle = "rgba(255,255,255,0.4)";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(o.x, o.y + o.h);
            ctx.lineTo(o.x + o.w / 2, o.y - 2);
            ctx.lineTo(o.x + o.w, o.y + o.h);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          });

          // boosts (floating blocks)
          ctx.fillStyle = "#facc15";
          ctx.strokeStyle = "rgba(255,255,255,0.5)";
          boosts.forEach(b => {
            ctx.fillRect(b.x, b.y, b.size, b.size);
            ctx.strokeRect(b.x, b.y, b.size, b.size);
          });

          ctx.fillStyle = "#e5e7eb";
          ctx.font = "13px sans-serif";
          ctx.textAlign = "left";
          ctx.fillText(`Score: ${Math.floor(score)}s`, 10, 18);
          ctx.fillStyle = "rgba(229,231,235,0.8)";
          ctx.fillText(running ? "Stay on the rail; jump only when grounded." : "Press Start or tap the canvas to run.", 10, 36);

          if (!alive) {
            ctx.fillStyle = "rgba(15,23,42,0.82)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#f97373";
            ctx.font = "15px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("You missed the floor line.", canvas.width / 2, canvas.height / 2 - 12);
            ctx.fillStyle = "#facc15";
            ctx.fillText("Hit Start / Restart or tap to try again.", canvas.width / 2, canvas.height / 2 + 10);
          }
        }

        function runnerLoop() {
          updateRunner();
          drawRunner();
          requestAnimationFrame(runnerLoop);
        }

        function jump() {
          const groundedRecently = player.onGround || performance.now() - lastGrounded < coyoteMs;
          if (!alive) {
            resetRunner(true);
            return;
          }
          if (!running) {
            resetRunner(true);
            return;
          }
          if (groundedRecently) {
            player.vy = jumpVelocity;
            player.onGround = false;
          }
        }

        canvas.addEventListener("click", jump);
        canvas.addEventListener("touchstart", function (e) {
          e.preventDefault();
          jump();
        });

        window.addEventListener("keydown", e => {
          const key = e.key.toLowerCase();
          if (key === " " || key === "spacebar") {
            e.preventDefault();
            jump();
          }
          if (key === "r") {
            resetRunner(true);
          }
        });

        startBtn.addEventListener("click", () => resetRunner(true));

        loadLeaderboard();
        renderLeaderboard();
        resetRunner(false);
        runnerLoop();
      })();

      /* ---------- HANGMAN ---------- */
      (function () {
        const wordEl = document.getElementById("hangman-word");
        const lettersEl = document.getElementById("hangman-letters");
        const statusEl = document.getElementById("hangman-status");
        const resetBtn = document.getElementById("hangman-reset");

        if (!wordEl || !lettersEl || !statusEl || !resetBtn) return;

        const words = [
          "BILL",
          "COMMITTEE",
          "QUORUM",
          "AMENDMENT",
          "CAUCUS",
          "RESOLUTION",
          "CHAMBER",
          "DRAFTING",
          "FLOOR",
          "GAVEL",
          "FILIBUSTER",
          "SPONSOR",
          "WHIP",
          "CONSENT",
          "APPEAL",
          "GERRYMANDER",
          "ABSTAIN",
          "YEA",
          "NAY",
          "CONFERENCE",
          "STATUTE",
          "COMMERCE",
          "DOCKET",
          "VETO"
        ];

        let secret, revealed, attempts;

        function pickWord() {
          secret = words[Math.floor(Math.random() * words.length)];
          revealed = Array(secret.length).fill("_");
          attempts = 7;
          wordEl.textContent = revealed.join(" ");
          statusEl.textContent = "You have 7 attempts.";
          renderLetters();
        }

        function renderLetters() {
          lettersEl.innerHTML = "";
          const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
          for (const ch of alphabet) {
            const btn = document.createElement("button");
            btn.textContent = ch;
            btn.addEventListener("click", () => guessLetter(ch, btn));
            lettersEl.appendChild(btn);
          }
        }

        function guessLetter(ch, btn) {
          btn.disabled = true;
          let hit = false;
          for (let i = 0; i < secret.length; i++) {
            if (secret[i] === ch) {
              revealed[i] = ch;
              hit = true;
            }
          }
          wordEl.textContent = revealed.join(" ");

          if (!hit) {
            attempts--;
          }

          if (!revealed.includes("_")) {
            statusEl.textContent =
              "You nailed it. Reward: smug confidence next time someone uses that word incorrectly.";
            disableAll();
          } else if (attempts <= 0) {
            statusEl.textContent = `Out of attempts. The word was: ${secret}.`;
            disableAll();
          } else {
            statusEl.textContent = `Attempts left: ${attempts}`;
          }
        }

        function disableAll() {
          const buttons = lettersEl.querySelectorAll("button");
          buttons.forEach(b => (b.disabled = true));
        }

        resetBtn.addEventListener("click", pickWord);
        pickWord();
      })();

      /* ---------- REACTION GAME ---------- */
      (function () {
        const startBtn = document.getElementById("reactionStart");
        const tapBtn = document.getElementById("reactionTap");
        const statusEl = document.getElementById("reactionStatus");
        const resultEl = document.getElementById("reactionResult");
        const bestEl = document.getElementById("reactionBest");
        if (!startBtn || !tapBtn || !statusEl || !resultEl || !bestEl) return;

        let waitingForGo = false;
        let liveRound = false;
        let startTime = 0;
        let timeoutId = null;
        let best = null;

        function labelForReaction(ms) {
          if (ms < 200) return "Elite reflex";
          if (ms < 280) return "Fast";
          if (ms < 360) return "Solid";
          if (ms < 450) return "Warming up";
          return "Keep practicing";
        }

        function scheduleRound() {
          clearTimeout(timeoutId);
          tapBtn.disabled = true;
          liveRound = false;
          waitingForGo = true;
          statusEl.textContent = "Hold steady… wait for GO.";
          resultEl.textContent = "";
          timeoutId = setTimeout(triggerGo, 1200 + Math.random() * 2200);
        }

        function triggerGo() {
          waitingForGo = false;
          liveRound = true;
          tapBtn.disabled = false;
          tapBtn.focus();
          statusEl.textContent = "GO! Tap now.";
          startTime = performance.now();
        }

        function endRound(message) {
          statusEl.textContent = message;
          tapBtn.disabled = true;
          liveRound = false;
        }

        startBtn.addEventListener("click", () => {
          scheduleRound();
        });

        tapBtn.addEventListener("click", () => {
          if (waitingForGo) {
            endRound("Too soon. Resetting the round.");
            clearTimeout(timeoutId);
            setTimeout(scheduleRound, 600);
            return;
          }

          if (!liveRound) return;
          const reaction = Math.round(performance.now() - startTime);
          resultEl.textContent = `Reaction time: ${reaction} ms (${labelForReaction(reaction)})`;
          if (best === null || reaction < best) {
            best = reaction;
            bestEl.textContent = `Personal best: ${best} ms`;
          }
          endRound("Nice reflexes. Start another round when ready.");
        });

        document.addEventListener("keydown", (event) => {
          if ((event.code === "Space" || event.key === " ") && !tapBtn.disabled) {
            event.preventDefault();
            tapBtn.click();
          }
        });

        bestEl.textContent = "Personal best: —";
      })();


    });
  </script>
</body>
</html>
