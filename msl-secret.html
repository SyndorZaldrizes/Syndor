<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Petroid Sector – SMCM MSL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="icon" type="image/png" href="logo-1.png" />

  <style>
    body.game-page {
      background: radial-gradient(circle at top, #020617, #000000);
      color: #e5e7eb;
    }

    .game-page h1,
    .game-page h2,
    .game-page h3 {
      color: #f9fafb;
    }

    .game-page .section {
      padding-top: 3rem;
      padding-bottom: 3rem;
    }

    .canvas-shell {
      background: #020617;
      border-radius: 0.75rem;
      padding: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.9);
      overflow: hidden;
    }

    .canvas-shell canvas {
      display: block;
      margin: 0 auto;
      max-width: 100%;
      background: #020617;
      border-radius: 0.5rem;
    }

    #gameHud {
      text-align: center;
      margin-top: 0.25rem;
      margin-bottom: 0.75rem;
      font-size: 0.85rem;
      color: #cbd5f5;
    }

    #gameMessage {
      text-align: center;
      margin-top: 0.75rem;
      font-size: 0.85rem;
      min-height: 1.2em;
    }

    /* Intro overlay */
    #introOverlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, #020617, #000000);
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }

    #introOverlay.hidden {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease-out;
    }

    #introCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .intro-message {
      position: relative;
      text-align: center;
      color: #e5e7eb;
      z-index: 2;
      max-width: 580px;
      padding: 1.5rem;
    }

    .intro-message h2 {
      margin-bottom: 0.5rem;
    }

    .intro-message p {
      font-size: 0.9rem;
      opacity: 0.9;
    }

    .intro-message small {
      display: block;
      margin-top: 0.5rem;
      font-size: 0.75rem;
      opacity: 0.8;
    }
  </style>
</head>

<body class="game-page">
  <header class="site-header">
    <div class="inner">
      <a href="index.html#hero" class="brand">
        <span class="brand-mark brand-mark-logo">
          <img src="logo-1.png" alt="SMCM MSL logo" />
        </span>
        <span class="brand-text">
          <span class="brand-title">Maryland Student Legislature</span>
          <span class="brand-sub">St. Mary’s College of Maryland Chapter</span>
        </span>
      </a>
      <button class="nav-toggle" id="navToggle" aria-label="Toggle navigation">☰</button>
      <nav class="nav" id="mainNav">
        <a href="index.html#hero">Home</a>
        <a href="index.html#maryland">About MSL</a>
        <a href="index.html#chapter">Our Chapter</a>
        <a href="index.html#journey">Your Journey</a>
        <a href="index.html#documents">Documents</a>
        <a href="executive-board.html">Exec Board</a>
        <a href="resources.html">Resources</a>
        <a href="bulletin.html">Bulletin</a>
        <a href="msl-game.html">Games</a>
        <a href="index.html#gallery">Gallery</a>
        <a href="index.html#contact">Join Us</a>
        <a href="msl-giving.html">GIVING TUESDAY CHAMPIONSHIP</a>
      </nav>
    </div>
  </header>

  <main>
    <section class="section">
      <div class="inner">
        <div class="section-header center">
          <p class="eyebrow">Hidden Level</p>
          <h1>Petroid Sector Run</h1>
          <p class="section-body">
            Move through the sector, avoid hazards, collect all stars, and reach the portal. 
            The world is split into three regions – Alpha, Beta, and Gamma – with different backdrops as you progress.
          </p>
        </div>

        <!-- Sector / status HUD ABOVE the game -->
        <p id="gameHud" class="small"></p>

        <div class="canvas-shell">
          <canvas id="metroidCanvas" width="960" height="384"></canvas>
        </div>

        <p id="gameMessage" class="small"></p>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="inner footer-inner">
      <p>© <span id="year"></span> Maryland Student Legislature – St. Mary’s College of Maryland Chapter.</p>
      <p class="small">
        Student-led, nonpartisan, and rooted in Maryland’s civic life. This site is maintained by the SMCM
        Maryland Student Legislature Chapter and is not an official publication of St. Mary’s College of
        Maryland or the State of Maryland.
      </p>
    </div>
  </footer>

  <!-- Galaxy intro overlay -->
  <div id="introOverlay">
    <canvas id="introCanvas"></canvas>
    <div class="intro-message">
      <h2>Petroid Sector: Online</h2>
      <p>
        Stars scattered. Portal dormant. Use your movement keys to explore the sector, 
        collect quorum, and stabilize the field.
      </p>
      <small>Press any key or click to begin.</small>
    </div>
  </div>

  <script src="script.js"></script>

  <!-- Page-specific JS -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      /* ==========================
         GALAXY INTRO STARFIELD
      =========================== */
      (function () {
        const overlay = document.getElementById("introOverlay");
        const canvas = document.getElementById("introCanvas");
        if (!overlay || !canvas) return;
        const ctx = canvas.getContext("2d");

        function resizeIntro() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }
        resizeIntro();
        window.addEventListener("resize", resizeIntro);

        const stars = [];
        const STAR_COUNT = 180;
        for (let i = 0; i < STAR_COUNT; i++) {
          stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            z: Math.random() * 1.5 + 0.5,
            r: Math.random() * 1.4 + 0.4
          });
        }

        let startTime = performance.now();
        let running = true;

        function drawIntroFrame(time) {
          if (!running) return;
          const dt = (time - startTime) / 1000;

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#020617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          stars.forEach(star => {
            star.y += star.z * 30 * (1 / 60);
            if (star.y > canvas.height) {
              star.y = 0;
              star.x = Math.random() * canvas.width;
            }
            const alpha = 0.3 + 0.7 * star.z;
            ctx.fillStyle = "rgba(148, 163, 184," + alpha.toFixed(2) + ")";
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
            ctx.fill();
          });

          const gradient = ctx.createRadialGradient(
            canvas.width * 0.7,
            canvas.height * 0.2,
            0,
            canvas.width * 0.7,
            canvas.height * 0.2,
            canvas.width * 0.7
          );
          gradient.addColorStop(0, "rgba(59, 130, 246, 0.22)");
          gradient.addColorStop(0.4, "rgba(129, 140, 248, 0.09)");
          gradient.addColorStop(1, "rgba(15, 23, 42, 0)");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          if (dt >= 7) {
            closeIntro();
            return;
          }
          requestAnimationFrame(drawIntroFrame);
        }

        function closeIntro() {
          running = false;
          overlay.classList.add("hidden");
        }

        overlay.addEventListener("click", closeIntro);
        window.addEventListener("keydown", closeIntro);

        requestAnimationFrame(drawIntroFrame);
      })();

      /* ==========================
         PETROID PLATFORMER
      =========================== */
      (function () {
        const canvas = document.getElementById("metroidCanvas");
        const hudEl = document.getElementById("gameHud");
        const messageEl = document.getElementById("gameMessage");
        if (!canvas || !hudEl || !messageEl) return;
        const ctx = canvas.getContext("2d");

        const TILE = 32;

        // Base layout (will be scaled horizontally later)
        const rawRows = [
          "................................................................................",
          "................................................................................",
          "................................................................................",
          "..................####....................####..................................",
          ".................#....#..................#....#.................................",
          "...............##......##..............##......##.............***..............",
          "................................................................................",
          "...P......***....................####...................####....................",
          "###########^^^^#########################^^^^#####################^^^^###########",
          "................................................................................",
          ".......................***....................####..............................",
          "..............####.....................***..#....#..............................",
          ".............#....#...........####..........#....#.............####.............",
          ".........***.#....#.........##....##....E..##....##...........#....#............",
          "#########^^^^######^^^^^^^^^######^^^^^^^^^^^^^^######^^^^^^^^######^^^^^^^^####",
          "................................................................................",
          "................................................................................"
        ];

        // Find spawn in raw rows, clean out 'P'
        let spawnRaw = { x: 2, y: 8 };

        const cleanedRows = rawRows.map((rowStr, y) => {
          const arr = rowStr.split("");
          arr.forEach((ch, x) => {
            if (ch === "P") {
              spawnRaw = { x, y };
              arr[x] = ".";
            }
          });
          return arr;
        });

        // Make the world ~100% wider by scaling horizontally
        const HORIZ_SCALE = 2;
        let rows = cleanedRows.map(row => {
          const newRow = [];
          row.forEach(ch => {
            for (let i = 0; i < HORIZ_SCALE; i++) newRow.push(ch);
          });
          return newRow;
        });

        const ROWS = rows.length;
        let COLS = 0;
        rows.forEach(r => {
          if (r.length > COLS) COLS = r.length;
        });

        function getTile(tx, ty) {
          if (ty < 0 || ty >= ROWS || tx < 0) return ".";
          const row = rows[ty];
          if (!row || tx >= row.length) return ".";
          return row[tx] || ".";
        }

        function setTile(tx, ty, ch) {
          if (ty < 0 || ty >= ROWS || tx < 0) return;
          const row = rows[ty];
          if (!row || tx >= row.length) return;
          row[tx] = ch;
        }

        function isSolid(ch) {
          return ch === "#";
        }
        function isHazard(ch) {
          return ch === "^";
        }
        function isPortal(ch) {
          return ch === "E";
        }
        function isStar(ch) {
          return ch === "*";
        }

        // Count stars in scaled rows
        let totalStars = 0;
        for (let y = 0; y < ROWS; y++) {
          const row = rows[y];
          for (let x = 0; x < row.length; x++) {
            if (row[x] === "*") totalStars++;
          }
        }

        // Spawn position uses scaled coords
        const spawn = {
          x: (spawnRaw.x * HORIZ_SCALE + 0.5),
          y: spawnRaw.y + 0.5
        };

        let collectedStars = 0;
        let sectorName = "Alpha";

        const worldWidth = COLS * TILE;

        function computeSectorName(x) {
          const clamped = Math.max(0, Math.min(worldWidth, x));
          const unit = worldWidth / 6; // 1:2:3 ratio => 6 "units"
          if (clamped < unit) return "Alpha";
          if (clamped < unit * 3) return "Beta";
          return "Gamma";
        }

        // Player state
        const player = {
          x: spawn.x * TILE,
          y: spawn.y * TILE,
          vx: 0,
          vy: 0,
          onGround: false,
          facing: 1
        };

        let keys = {
          left: false,
          right: false,
          jump: false
        };

        const GRAVITY = 1400;
        const MOVE_ACCEL = 2500;
        const MAX_SPEED = 260;
        const JUMP_VELOCITY = -520;
        const FRICTION = 0.9;

        const PLAYER_W = 22;
        const PLAYER_H = 30;

        // Camera
        let cameraX = 0;
        let cameraY = 0;

        let gameWon = false;

        // Single metroid sprite (optional)
        const metroidSprite = new Image();
        metroidSprite.src = "petroid-core.png"; // upload later if you want; otherwise it uses fallback orb

        // Sector backgrounds (optional)
        const sectorBackgrounds = {
          Alpha: new Image(),
          Beta: new Image(),
          Gamma: new Image()
        };
        sectorBackgrounds.Alpha.src = "secret-bg-alpha.jpg";
        sectorBackgrounds.Beta.src = "secret-bg-beta.jpg";
        sectorBackgrounds.Gamma.src = "secret-bg-gamma.jpg";

        // HUD + messages
        let lastStatus = "Online";

        function updateHud(statusText) {
          if (statusText) lastStatus = statusText;
          hudEl.textContent =
            "Stars: " +
            collectedStars +
            " / " +
            totalStars +
            " · Sector: " +
            sectorName +
            " · Status: " +
            (gameWon ? "Beacon online" : lastStatus);
        }

        function showMessage(text) {
          messageEl.textContent = text || "";
        }

        function respawn() {
          player.x = spawn.x * TILE;
          player.y = spawn.y * TILE;
          player.vx = 0;
          player.vy = 0;
          player.onGround = false;
          gameWon = false;
          showMessage("Respawned at last safe node.");
          updateHud("Online");
        }

        updateHud();
        showMessage("Collect stars and head toward the portal. Spikes reset you.");

        // Keyboard input
        window.addEventListener("keydown", (e) => {
          const key = e.key.toLowerCase();
          if (["arrowleft", "a"].includes(key)) {
            keys.left = true;
            e.preventDefault();
          }
          if (["arrowright", "d"].includes(key)) {
            keys.right = true;
            e.preventDefault();
          }
          if ([" ", "arrowup", "w"].includes(key)) {
            keys.jump = true;
            e.preventDefault();
          }
          if (key === "r") {
            respawn();
            e.preventDefault();
          }
        });

        window.addEventListener("keyup", (e) => {
          const key = e.key.toLowerCase();
          if (["arrowleft", "a"].includes(key)) {
            keys.left = false;
          }
          if (["arrowright", "d"].includes(key)) {
            keys.right = false;
          }
          if ([" ", "arrowup", "w"].includes(key)) {
            keys.jump = false;
          }
        });

        // Physics and collision
        function rectVsTileCollision(x, y, w, h, vx, vy, dt) {
          let newX = x + vx * dt;
          let newY = y + vy * dt;
          let onGround = false;

          // Horizontal
          if (vx !== 0) {
            const dirX = Math.sign(vx);
            const aheadX = dirX > 0 ? newX + w / 2 : newX - w / 2;
            const topY = newY - h / 2 + 2;
            const bottomY = newY + h / 2 - 2;

            const tileTop = Math.floor(topY / TILE);
            const tileBottom = Math.floor(bottomY / TILE);
            const tileX = Math.floor(aheadX / TILE);

            for (let ty = tileTop; ty <= tileBottom; ty++) {
              const ch = getTile(tileX, ty);
              if (isSolid(ch)) {
                if (dirX > 0) {
                  newX = tileX * TILE - w / 2;
                } else {
                  newX = (tileX + 1) * TILE + w / 2;
                }
                vx = 0;
                break;
              }
            }
          }

          // Vertical
          if (vy !== 0) {
            const dirY = Math.sign(vy);
            const aheadY = dirY > 0 ? newY + h / 2 : newY - h / 2;
            const leftX = newX - w / 2 + 4;
            const rightX = newX + w / 2 - 4;

            const tileLeft = Math.floor(leftX / TILE);
            const tileRight = Math.floor(rightX / TILE);
            const tileY = Math.floor(aheadY / TILE);

            for (let tx = tileLeft; tx <= tileRight; tx++) {
              const ch = getTile(tx, tileY);
              if (isSolid(ch)) {
                if (dirY > 0) {
                  newY = tileY * TILE - h / 2;
                  onGround = true;
                } else {
                  newY = (tileY + 1) * TILE + h / 2;
                }
                vy = 0;
                break;
              }
            }
          }

          return { x: newX, y: newY, vx, vy, onGround };
        }

        // More precise hazards/stars/portal check
        function checkHazardsAndStars(px, py, w, h) {
          let hazardHit = false;
          let portalHit = false;

          const left = Math.floor((px - w / 2) / TILE);
          const right = Math.floor((px + w / 2) / TILE);
          const top = Math.floor((py - h / 2) / TILE);
          const bottom = Math.floor((py + h / 2) / TILE);

          const playerRect = {
            x: px - w / 2,
            y: py - h / 2,
            w: w,
            h: h
          };

          function rectsOverlap(a, b) {
            return !(
              a.x + a.w <= b.x ||
              a.x >= b.x + b.w ||
              a.y + a.h <= b.y ||
              a.y >= b.y + b.h
            );
          }

          for (let ty = top; ty <= bottom; ty++) {
            for (let tx = left; tx <= right; tx++) {
              const ch = getTile(tx, ty);
              const tileX = tx * TILE;
              const tileY = ty * TILE;

              if (isStar(ch)) {
                // full tile collision is fine for stars
                const starRect = {
                  x: tileX + TILE * 0.2,
                  y: tileY + TILE * 0.2,
                  w: TILE * 0.6,
                  h: TILE * 0.6
                };
                if (rectsOverlap(playerRect, starRect)) {
                  setTile(tx, ty, ".");
                  collectedStars++;
                  updateHud("Quorum strengthened");
                  showMessage("Star collected. Current quorum: " + collectedStars + ".");
                }
              }

              if (isHazard(ch)) {
                // Shrink hazard hitbox so it's closer to the visible spikes
                const hazardRect = {
                  x: tileX + TILE * 0.15,
                  y: tileY + TILE * 0.4,
                  w: TILE * 0.7,
                  h: TILE * 0.55
                };
                if (rectsOverlap(playerRect, hazardRect)) {
                  hazardHit = true;
                }
              }

              if (isPortal(ch)) {
                const portalRect = {
                  x: tileX + TILE * 0.1,
                  y: tileY + TILE * 0.1,
                  w: TILE * 0.8,
                  h: TILE * 0.8
                };
                if (rectsOverlap(playerRect, portalRect)) {
                  portalHit = true;
                }
              }
            }
          }

          return { hazardHit, portalHit };
        }

        function updateCamera() {
          const targetX = player.x - canvas.width / 2;
          const maxCamX = COLS * TILE - canvas.width;
          cameraX = Math.max(0, Math.min(maxCamX, targetX));
          cameraY = 0;
        }

        function drawBackground() {
          const bg = sectorBackgrounds[sectorName];
          if (bg && bg.complete && bg.naturalWidth > 0) {
            const scale = Math.max(
              canvas.width / bg.naturalWidth,
              canvas.height / bg.naturalHeight
            );
            const drawW = bg.naturalWidth * scale;
            const drawH = bg.naturalHeight * scale;
            const dx = (canvas.width - drawW) / 2;
            const dy = (canvas.height - drawH) / 2;
            ctx.drawImage(bg, dx, dy, drawW, drawH);
          } else {
            let topColor = "#020617";
            let bottomColor = "#020617";
            if (sectorName === "Alpha") {
              topColor = "#020617";
              bottomColor = "#020617";
            } else if (sectorName === "Beta") {
              topColor = "#0b1120";
              bottomColor = "#020617";
            } else {
              topColor = "#020617";
              bottomColor = "#000000";
            }
            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, topColor);
            grad.addColorStop(1, bottomColor);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        }

        function drawWorld() {
          drawBackground();

          const startCol = Math.floor(cameraX / TILE);
          const endCol = Math.ceil((cameraX + canvas.width) / TILE);

          for (let y = 0; y < ROWS; y++) {
            for (let x = startCol; x <= endCol; x++) {
              const ch = getTile(x, y);
              if (ch === ".") continue;
              const screenX = x * TILE - cameraX;
              const screenY = y * TILE - cameraY;

              if (isSolid(ch)) {
                ctx.fillStyle = "#111827";
                ctx.fillRect(screenX, screenY, TILE, TILE);
                ctx.strokeStyle = "#1f2937";
                ctx.strokeRect(screenX, screenY, TILE, TILE);
              } else if (isHazard(ch)) {
                ctx.fillStyle = "#b91c1c";
                ctx.beginPath();
                ctx.moveTo(screenX, screenY + TILE);
                ctx.lineTo(screenX + TILE / 2, screenY + TILE * 0.3);
                ctx.lineTo(screenX + TILE, screenY + TILE);
                ctx.closePath();
                ctx.fill();
              } else if (isStar(ch)) {
                ctx.fillStyle = "#facc15";
                ctx.beginPath();
                const cx = screenX + TILE / 2;
                const cy = screenY + TILE / 2;
                ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#f97316";
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
              } else if (isPortal(ch)) {
                const cx = screenX + TILE / 2;
                const cy = screenY + TILE / 2;
                const r = TILE * 0.4;
                const inner = r * 0.55;
                const alpha = 0.75;
                ctx.beginPath();
                ctx.strokeStyle = "rgba(129, 140, 248," + alpha + ")";
                ctx.lineWidth = 3;
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.strokeStyle = "rgba(56, 189, 248," + alpha + ")";
                ctx.arc(cx, cy, inner, 0, Math.PI * 2);
                ctx.stroke();
              }
            }
          }
        }

        function drawPlayer() {
          const screenX = player.x - cameraX;
          const screenY = player.y - cameraY;
          const sprite = metroidSprite;
          const spriteReady = sprite && sprite.complete && sprite.naturalWidth > 0;

          if (spriteReady) {
            const scale = 0.7;
            const drawW = sprite.width * scale;
            const drawH = sprite.height * scale;
            const dx = screenX - drawW / 2;
            const dy = screenY - drawH / 2;

            ctx.save();
            if (player.facing < 0) {
              ctx.translate(screenX, 0);
              ctx.scale(-1, 1);
              ctx.drawImage(sprite, -drawW / 2, dy, drawW, drawH);
            } else {
              ctx.drawImage(sprite, dx, dy, drawW, drawH);
            }
            ctx.restore();
          } else {
            // Energy-orb fallback
            ctx.save();
            ctx.translate(screenX, screenY);
            const radius = 14;
            const grad = ctx.createRadialGradient(-4, -5, 2, 0, 0, radius);
            grad.addColorStop(0, "#facc15");
            grad.addColorStop(0.5, "#f97316");
            grad.addColorStop(1, "#111827");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        // Game loop
        let lastTime = performance.now();

        function step(timestamp) {
          const dt = Math.min((timestamp - lastTime) / 1000, 0.03);
          lastTime = timestamp;

          update(dt);
          render();
          requestAnimationFrame(step);
        }

        function update(dt) {
          if (gameWon) {
            player.vy = Math.sin(performance.now() / 500) * 10;
          } else {
            let moveDir = 0;
            if (keys.left) moveDir -= 1;
            if (keys.right) moveDir += 1;

            if (moveDir !== 0) {
              player.facing = moveDir;
              player.vx += moveDir * MOVE_ACCEL * dt;
            } else {
              player.vx *= FRICTION;
            }

            if (player.vx > MAX_SPEED) player.vx = MAX_SPEED;
            if (player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;

            if (keys.jump && player.onGround) {
              player.vy = JUMP_VELOCITY;
              player.onGround = false;
            }

            player.vy += GRAVITY * dt;

            const res = rectVsTileCollision(
              player.x,
              player.y,
              PLAYER_W,
              PLAYER_H,
              player.vx,
              player.vy,
              dt
            );
            player.x = res.x;
            player.y = res.y;
            player.vx = res.vx;
            player.vy = res.vy;
            player.onGround = res.onGround;

            const checks = checkHazardsAndStars(
              player.x,
              player.y,
              PLAYER_W,
              PLAYER_H
            );

            if (checks.hazardHit && !gameWon) {
              showMessage("Hazard hit. Respawning…");
              respawn();
            }

            if (checks.portalHit && collectedStars >= totalStars && !gameWon) {
              gameWon = true;
              showMessage("Portal reached with full quorum. Sector stabilized.");
              updateHud("Beacon online");
            } else if (checks.portalHit && !gameWon) {
              showMessage(
                "Portal detected, but quorum is low. Stars: " +
                  collectedStars +
                  " / " +
                  totalStars +
                  "."
              );
            }
          }

          sectorName = computeSectorName(player.x);
          updateCamera();
          updateHud();
        }

        function render() {
          drawWorld();
          drawPlayer();

          // Foreground stars tied to camera
          ctx.save();
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = "#9ca3af";
          for (let i = 0; i < 40; i++) {
            const sx = ((i * 137 + cameraX * 0.3) % canvas.width);
            const sy = (i * 59) % canvas.height;
            ctx.fillRect(sx, sy, 2, 2);
          }
          ctx.restore();
        }

        respawn();
        requestAnimationFrame(step);
      })();
    });
  </script>
</body>
</html>
