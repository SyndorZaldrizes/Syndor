<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MSL Secret Lab ‚Äì Petroid Sector</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="icon" type="image/png" href="logo-1.png" />

  <!-- Page-specific styles -->
  <style>
    body.secret-game-page {
      background: radial-gradient(circle at top, #020617, #000000);
      color: #f9fafb;
      overflow-x: hidden;
    }
    .secret-game-page .section {
      padding-top: 3rem;
      padding-bottom: 3rem;
    }
    .secret-game-page h1,
    .secret-game-page h2,
    .secret-game-page h3 {
      color: #f9fafb;
    }
    .secret-shell {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    @media (min-width: 1024px) {
      .secret-shell {
        flex-direction: row;
        align-items: flex-start;
      }
      .secret-main {
        flex: 3;
      }
      .secret-side {
        flex: 2;
      }
    }

    .secret-main-card,
    .secret-side-card {
      background: rgba(15, 23, 42, 0.95);
      border-radius: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      box-shadow: 0 20px 50px rgba(15, 23, 42, 0.8);
      padding: 1.25rem;
    }

    .game-canvas-shell {
      background: radial-gradient(circle at top, #020617, #000000);
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      padding: 0.5rem;
      text-align: center;
    }
    .game-canvas-shell canvas {
      display: block;
      margin: 0 auto;
      max-width: 100%;
      border-radius: 0.5rem;
      background: #020617;
    }

    .controls-text {
      font-size: 0.8rem;
      opacity: 0.9;
      margin-top: 0.35rem;
    }

    .pet-form-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin-top: 0.5rem;
    }
    .pet-form-controls button {
      border-radius: 999px;
      padding: 0.25rem 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.95);
      color: #e5e7eb;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .pet-form-controls button.active {
      background: rgba(37, 99, 235, 0.65);
      border-color: rgba(129, 140, 248, 0.9);
    }
    .pet-form-controls button:hover {
      background: rgba(37, 99, 235, 0.4);
    }

    .hud-line {
      font-size: 0.85rem;
      margin-top: 0.35rem;
      opacity: 0.9;
    }

    /* Galaxy intro overlay */
    #introOverlay {
      position: fixed;
      inset: 0;
      z-index: 60;
      background: radial-gradient(circle at top, #020617, #000000);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: #e5e7eb;
    }
    #introOverlay.hidden {
      display: none;
    }
    #introCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }
    .intro-content {
      position: relative;
      text-align: center;
      padding: 1.5rem;
      max-width: 560px;
      z-index: 2;
    }
    .intro-content h1 {
      font-size: 1.8rem;
      margin-bottom: 0.75rem;
    }
    .intro-content p {
      font-size: 0.95rem;
      color: #e5e7eb;
    }
    .intro-hint {
      margin-top: 0.75rem;
      font-size: 0.8rem;
      opacity: 0.85;
    }

    /* Message overlay inside the game card */
    #gameMessage {
      margin-top: 0.6rem;
      font-size: 0.85rem;
      min-height: 1.5em;
    }
  </style>
</head>

<body class="secret-game-page">
  <header class="site-header">
    <div class="inner">
      <a href="index.html#hero" class="brand">
        <span class="brand-mark brand-mark-logo">
          <img src="logo-1.png" alt="SMCM MSL logo" />
        </span>
        <span class="brand-text">
          <span class="brand-title">Maryland Student Legislature</span>
          <span class="brand-sub">St. Mary‚Äôs College of Maryland Chapter</span>
        </span>
      </a>
      <button class="nav-toggle" id="navToggle" aria-label="Toggle navigation">‚ò∞</button>
      <nav class="nav" id="mainNav">
        <a href="index.html#hero">Home</a>
        <a href="index.html#maryland">About MSL</a>
        <a href="index.html#chapter">Our Chapter</a>
        <a href="index.html#journey">Your Journey</a>
        <a href="index.html#documents">Documents</a>
        <a href="executive-board.html">Exec Board</a>
        <a href="resources.html">Resources</a>
        <a href="bulletin.html">Bulletin</a>
        <a href="msl-game.html">Games</a>
        <a href="index.html#gallery">Gallery</a>
        <a href="index.html#contact">Join Us</a>
        <a href="msl-giving.html">GIVING TUESDAY CHAMPIONSHIP</a>
      </nav>
    </div>
  </header>

  <!-- GALAXY INTRO OVERLAY -->
  <div id="introOverlay">
    <canvas id="introCanvas"></canvas>
    <div class="intro-content">
      <h1>Petroid: MSL Sector</h1>
      <p>
        In a quiet corner of the legislative galaxy, a lone field-companion drifts between abandoned
        chambers, gathering lost stars of quorum to re-ignite the MSL Beacon.
      </p>
      <p style="margin-top:0.5rem;">
        Guide your companion across forgotten platforms, dodge the hazards of broken procedure, and
        find the exit portal back to session.
      </p>
      <p class="intro-hint">
        Press any key or click to skip. The adventure begins in a few seconds‚Ä¶
      </p>
    </div>
  </div>

  <main>
    <section class="section">
      <div class="inner">
        <div class="section-header">
          <p class="eyebrow">Hidden Experiments</p>
          <h1>MSL Secret Lab ‚Äì Petroid Sector</h1>
          <p class="section-body">
            You‚Äôve unlocked a tucked-away test chamber. This is a small Metroid-style experiment:
            pick your animal form, explore a side-scrolling world, collect quorum stars, dodge hazards,
            and reach the portal on the far side of the map.
          </p>
          <p class="section-body" style="font-size:0.9rem; opacity:0.85;">
            Best experienced on desktop with a keyboard. The game will still load on mobile, but
            controls and precision jumps are tuned for a laptop or PC.
          </p>
        </div>

        <div class="secret-shell">
          <!-- MAIN GAME CARD -->
          <div class="secret-main">
            <article class="secret-main-card">
              <h2>Petroid: Sector Run</h2>
              <p class="small">
                Move through the map, gather stars, and find the portal. Your chosen animal form is
                your ‚Äúmetroid‚Äù core.
              </p>

              <div class="game-canvas-shell">
                <canvas id="metroidCanvas" width="960" height="540"></canvas>
              </div>

              <p class="controls-text">
                <strong>Controls:</strong>
                A / Left = move left ¬∑ D / Right = move right ¬∑ W / Up / Space = jump ¬∑ R = respawn
              </p>

              <div class="pet-form-controls">
                <!-- Uses PNGs if present: metroid-dog.png, metroid-cat.png, metroid-koala.png -->
                <button type="button" data-form="dog" class="active">Dog Form üê∂</button>
                <button type="button" data-form="cat">Cat Form üê±</button>
                <button type="button" data-form="koala">Koala Form üê®</button>
              </div>

              <p id="gameHud" class="hud-line">
                Stars: 0 / 8 ¬∑ Sector: Alpha ¬∑ Status: Online
              </p>
              <p id="gameMessage" class="small"></p>
            </article>
          </div>

          <!-- SIDE CARD: LORE / HINTS -->
          <div class="secret-side">
            <article class="secret-side-card">
              <h2>Sector Notes & Hints</h2>
              <ul class="checklist small">
                <li>Collect quorum stars <strong>(‚òÖ)</strong> scattered across platforms.</li>
                <li>Spikes <strong>(^)</strong> and red hazard tiles reset you to the spawn point.</li>
                <li>The glowing portal activates once you‚Äôve collected enough stars.</li>
                <li>Use short taps of jump near edges to control your arc and avoid over-shooting.</li>
                <li>If you get stuck, press <strong>R</strong> to respawn at the last safe spawn.</li>
              </ul>
              <p class="small" style="margin-top:0.75rem;">
                Under the hood this is a tiny prototype: simple tile physics, a following camera, and
                a handful of zones. If you want to expand it later, we can add additional ‚Äúsectors‚Äù
                off the main map, environmental switches, or even simple NPCs.
              </p>
            </article>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="inner footer-inner">
      <p>¬© <span id="year"></span> Maryland Student Legislature ‚Äì St. Mary‚Äôs College of Maryland Chapter.</p>
      <p class="small">
        Student-led, nonpartisan, and rooted in Maryland‚Äôs civic life. This site is maintained by the SMCM
        Maryland Student Legislature Chapter and is not an official publication of St. Mary‚Äôs College of
        Maryland or the State of Maryland.
      </p>
    </div>
  </footer>

  <script src="script.js"></script>

  <!-- Page-specific JS -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      /* ==========================
         GALAXY INTRO STARFIELD
      =========================== */
      (function () {
        const overlay = document.getElementById("introOverlay");
        const canvas = document.getElementById("introCanvas");
        if (!overlay || !canvas) return;
        const ctx = canvas.getContext("2d");

        function resizeIntro() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }
        resizeIntro();
        window.addEventListener("resize", resizeIntro);

        const stars = [];
        const STAR_COUNT = 180;
        for (let i = 0; i < STAR_COUNT; i++) {
          stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            z: Math.random() * 1.5 + 0.5,
            r: Math.random() * 1.4 + 0.4
          });
        }

        let startTime = performance.now();
        let running = true;

        function drawIntroFrame(time) {
          if (!running) return;
          const dt = (time - startTime) / 1000;

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#020617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          stars.forEach(star => {
            star.y += star.z * 30 * (1 / 60);
            if (star.y > canvas.height) {
              star.y = 0;
              star.x = Math.random() * canvas.width;
            }
            const alpha = 0.3 + 0.7 * star.z;
            ctx.fillStyle = "rgba(148, 163, 184," + alpha.toFixed(2) + ")";
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
            ctx.fill();
          });

          // Faint nebula sweep
          const gradient = ctx.createRadialGradient(
            canvas.width * 0.7,
            canvas.height * 0.2,
            0,
            canvas.width * 0.7,
            canvas.height * 0.2,
            canvas.width * 0.7
          );
          gradient.addColorStop(0, "rgba(59, 130, 246, 0.22)");
          gradient.addColorStop(0.4, "rgba(129, 140, 248, 0.09)");
          gradient.addColorStop(1, "rgba(15, 23, 42, 0)");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Auto-hide after ~7 seconds
          if (dt >= 7) {
            closeIntro();
            return;
          }
          requestAnimationFrame(drawIntroFrame);
        }

        function closeIntro() {
          running = false;
          overlay.classList.add("hidden");
        }

        overlay.addEventListener("click", closeIntro);
        window.addEventListener("keydown", closeIntro);

        requestAnimationFrame(drawIntroFrame);
      })();

      /* ==========================
         PETROID PLATFORMER
      =========================== */
      (function () {
        const canvas = document.getElementById("metroidCanvas");
        const hudEl = document.getElementById("gameHud");
        const messageEl = document.getElementById("gameMessage");
        const formButtons = document.querySelectorAll(".pet-form-controls button");
        if (!canvas || !hudEl || !messageEl) return;
        const ctx = canvas.getContext("2d");

        const TILE = 32;

        // Level layout (80 tiles wide x 17 tiles high)
        // Legend:
        // . = empty, # = solid, ^ = spike, * = star, P = spawn, E = exit portal
        const rawRows = [
          "................................................................................",
          "................................................................................",
          "................................................................................",
          "..................####....................####..................................",
          ".................#....#..................#....#.................................",
          "...............##......##..............##......##.............***..............",
          "................................................................................",
          "...P......***....................####...................####....................",
          "###########^^^^#########################^^^^#####################^^^^###########",
          "................................................................................",
          ".......................***....................####..............................",
          "..............####.....................***..#....#..............................",
          ".............#....#...........####..........#....#.............####.............",
          ".........***.#....#.........##....##....E..##....##...........#....#............",
          "#########^^^^######^^^^^^^^^######^^^^^^^^^^^^^^######^^^^^^^^######^^^^^^^^####",
          "................................................................................",
          "................................................................................"
        ];

        const rows = rawRows.map(r => r.split(""));
        const ROWS = rows.length;
        const COLS = rows[0].length;

        function getTile(tx, ty) {
          if (tx < 0 || ty < 0 || tx >= COLS || ty >= ROWS) return ".";
          return rows[ty][tx] || ".";
        }

        function setTile(tx, ty, ch) {
          if (tx < 0 || ty < 0 || tx >= COLS || ty >= ROWS) return;
          rows[ty][tx] = ch;
        }

        function isSolid(ch) {
          return ch === "#";
        }
        function isHazard(ch) {
          return ch === "^";
        }
        function isPortal(ch) {
          return ch === "E";
        }
        function isStar(ch) {
          return ch === "*";
        }

        // Find spawn and count stars
        let spawn = { x: 2, y: 8 };
        let totalStars = 0;
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            const ch = rows[y][x];
            if (ch === "P") {
              spawn = { x, y };
              rows[y][x] = "."; // clear spawn tile
            }
            if (ch === "*") totalStars++;
          }
        }

        let collectedStars = 0;
        let sectorName = "Alpha";

        // Player state
        const player = {
          x: (spawn.x + 0.5) * TILE,
          y: (spawn.y + 0.5) * TILE,
          vx: 0,
          vy: 0,
          onGround: false,
          facing: 1
        };

        let keys = {
          left: false,
          right: false,
          jump: false
        };

        const GRAVITY = 1400;   // px/s^2
        const MOVE_ACCEL = 2500;
        const MAX_SPEED = 260;
        const JUMP_VELOCITY = -520;
        const FRICTION = 0.9;

        const PLAYER_W = 22;
        const PLAYER_H = 30;

        // Camera
        let cameraX = 0;
        let cameraY = 0;

        // Game flags
        let gameWon = false;

        // Pet form / sprites
        const petSprites = {
          dog: new Image(),
          cat: new Image(),
          koala: new Image()
        };
        // Optional sprite files (you can rename these or swap for your own)
        petSprites.dog.src = "metroid-dog.png";
        petSprites.cat.src = "metroid-cat.png";
        petSprites.koala.src = "metroid-koala.png";

        let currentForm = "dog";

        function setForm(form) {
          if (!petSprites[form]) return;
          currentForm = form;
          formButtons.forEach(btn => {
            if (btn.getAttribute("data-form") === form) {
              btn.classList.add("active");
            } else {
              btn.classList.remove("active");
            }
          });
        }

        formButtons.forEach(btn => {
          const form = btn.getAttribute("data-form");
          btn.addEventListener("click", () => setForm(form));
        });

        // HUD + messages
        function updateHud(statusText) {
          const sName = sectorName;
          hudEl.textContent =
            "Stars: " +
            collectedStars +
            " / " +
            totalStars +
            " ¬∑ Sector: " +
            sName +
            " ¬∑ Status: " +
            (statusText || (gameWon ? "Portal secured" : "Online"));
        }

        function showMessage(text) {
          messageEl.textContent = text || "";
        }

        updateHud();
        showMessage("Collect stars and head right. Spikes reset you.");

        // Respawn
        function respawn() {
          player.x = (spawn.x + 0.5) * TILE;
          player.y = (spawn.y + 0.5) * TILE;
          player.vx = 0;
          player.vy = 0;
          player.onGround = false;
          gameWon = false;
          showMessage("Respawned at last safe node.");
          updateHud("Online");
        }

        // Keyboard handling
        window.addEventListener("keydown", (e) => {
          const key = e.key.toLowerCase();
          if (["arrowleft", "a"].includes(key)) {
            keys.left = true;
            e.preventDefault();
          }
          if (["arrowright", "d"].includes(key)) {
            keys.right = true;
            e.preventDefault();
          }
          if ([" ", "arrowup", "w"].includes(key)) {
            keys.jump = true;
            e.preventDefault();
          }
          if (key === "r") {
            respawn();
            e.preventDefault();
          }
        });

        window.addEventListener("keyup", (e) => {
          const key = e.key.toLowerCase();
          if (["arrowleft", "a"].includes(key)) {
            keys.left = false;
          }
          if (["arrowright", "d"].includes(key)) {
            keys.right = false;
          }
          if ([" ", "arrowup", "w"].includes(key)) {
            keys.jump = false;
          }
        });

        // Physics helpers
        function rectVsTileCollision(x, y, w, h, vx, vy, dt) {
          let newX = x + vx * dt;
          let newY = y + vy * dt;
          let onGround = false;

          // Horizontal
          if (vx !== 0) {
            const dirX = Math.sign(vx);
            const aheadX = dirX > 0 ? newX + w / 2 : newX - w / 2;
            const topY = newY - h / 2 + 2;
            const bottomY = newY + h / 2 - 2;

            const tileTop = Math.floor(topY / TILE);
            const tileBottom = Math.floor(bottomY / TILE);
            const tileX = Math.floor(aheadX / TILE);

            for (let ty = tileTop; ty <= tileBottom; ty++) {
              const ch = getTile(tileX, ty);
              if (isSolid(ch)) {
                // Snap to edge
                if (dirX > 0) {
                  newX = tileX * TILE - w / 2;
                } else {
                  newX = (tileX + 1) * TILE + w / 2;
                }
                vx = 0;
                break;
              }
            }
          }

          // Vertical
          if (vy !== 0) {
            const dirY = Math.sign(vy);
            const aheadY = dirY > 0 ? newY + h / 2 : newY - h / 2;
            const leftX = newX - w / 2 + 4;
            const rightX = newX + w / 2 - 4;

            const tileLeft = Math.floor(leftX / TILE);
            const tileRight = Math.floor(rightX / TILE);
            const tileY = Math.floor(aheadY / TILE);

            for (let tx = tileLeft; tx <= tileRight; tx++) {
              const ch = getTile(tx, tileY);
              if (isSolid(ch)) {
                if (dirY > 0) {
                  newY = tileY * TILE - h / 2;
                  onGround = true;
                } else {
                  newY = (tileY + 1) * TILE + h / 2;
                }
                vy = 0;
                break;
              }
            }
          }

          return { x: newX, y: newY, vx, vy, onGround };
        }

        function checkHazardsAndStars(px, py, w, h) {
          let hazardHit = false;
          let portalHit = false;

          const left = Math.floor((px - w / 2) / TILE);
          const right = Math.floor((px + w / 2) / TILE);
          const top = Math.floor((py - h / 2) / TILE);
          const bottom = Math.floor((py + h / 2) / TILE);

          for (let ty = top; ty <= bottom; ty++) {
            for (let tx = left; tx <= right; tx++) {
              const ch = getTile(tx, ty);
              if (isHazard(ch)) {
                hazardHit = true;
              }
              if (isPortal(ch)) {
                portalHit = true;
              }
              if (isStar(ch)) {
                setTile(tx, ty, ".");
                collectedStars++;
                updateHud("Quorum strengthened");
                showMessage("Star collected. Current quorum: " + collectedStars + ".");
              }
            }
          }

          return { hazardHit, portalHit };
        }

        // Camera follow
        function updateCamera() {
          const targetX = player.x - canvas.width / 2;
          const maxCamX = COLS * TILE - canvas.width;
          cameraX = Math.max(0, Math.min(maxCamX, targetX));
          cameraY = 0;
        }

        // Drawing
        function drawWorld() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Background gradient
          const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
          grad.addColorStop(0, "#020617");
          grad.addColorStop(1, "#020617");
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          const startCol = Math.floor(cameraX / TILE);
          const endCol = Math.ceil((cameraX + canvas.width) / TILE);

          for (let y = 0; y < ROWS; y++) {
            for (let x = startCol; x <= endCol; x++) {
              const ch = getTile(x, y);
              if (ch === ".") continue;
              const screenX = x * TILE - cameraX;
              const screenY = y * TILE - cameraY;

              if (isSolid(ch)) {
                ctx.fillStyle = "#1f2933";
                ctx.fillRect(screenX, screenY, TILE, TILE);
                ctx.strokeStyle = "#374151";
                ctx.strokeRect(screenX, screenY, TILE, TILE);
              } else if (isHazard(ch)) {
                ctx.fillStyle = "#b91c1c";
                ctx.beginPath();
                ctx.moveTo(screenX, screenY + TILE);
                ctx.lineTo(screenX + TILE / 2, screenY + TILE * 0.3);
                ctx.lineTo(screenX + TILE, screenY + TILE);
                ctx.closePath();
                ctx.fill();
              } else if (isStar(ch)) {
                ctx.fillStyle = "#facc15";
                ctx.beginPath();
                const cx = screenX + TILE / 2;
                const cy = screenY + TILE / 2;
                ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#f97316";
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
              } else if (isPortal(ch)) {
                const cx = screenX + TILE / 2;
                const cy = screenY + TILE / 2;
                const r = TILE * 0.4;
                const inner = r * 0.55;
                const alpha = 0.75;
                ctx.beginPath();
                ctx.strokeStyle = "rgba(129, 140, 248," + alpha + ")";
                ctx.lineWidth = 3;
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.strokeStyle = "rgba(56, 189, 248," + alpha + ")";
                ctx.arc(cx, cy, inner, 0, Math.PI * 2);
                ctx.stroke();
              }
            }
          }
        }

        function drawPlayer() {
          const screenX = player.x - cameraX;
          const screenY = player.y - cameraY;

          const sprite = petSprites[currentForm];
          const spriteReady = sprite && sprite.complete && sprite.naturalWidth > 0;

          if (spriteReady) {
            const scale = 0.7;
            const drawW = sprite.width * scale;
            const drawH = sprite.height * scale;
            const dx = screenX - drawW / 2;
            const dy = screenY - drawH / 2;

            ctx.save();
            if (player.facing < 0) {
              ctx.translate(screenX, 0);
              ctx.scale(-1, 1);
              ctx.drawImage(sprite, -drawW / 2, dy, drawW, drawH);
            } else {
              ctx.drawImage(sprite, dx, dy, drawW, drawH);
            }
            ctx.restore();
          } else {
            // Fallback orb
            ctx.save();
            ctx.translate(screenX, screenY);
            const radius = 14;
            const grad = ctx.createRadialGradient(-4, -5, 2, 0, 0, radius);
            grad.addColorStop(0, "#facc15");
            grad.addColorStop(0.5, "#f97316");
            grad.addColorStop(1, "#1f2933");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        // Game loop
        let lastTime = performance.now();

        function step(timestamp) {
          const dt = Math.min((timestamp - lastTime) / 1000, 0.03);
          lastTime = timestamp;

          update(dt);
          render();
          requestAnimationFrame(step);
        }

        function update(dt) {
          if (gameWon) {
            // Slight float effect when done
            player.vy = Math.sin(performance.now() / 500) * 10;
          } else {
            // Movement
            let moveDir = 0;
            if (keys.left) moveDir -= 1;
            if (keys.right) moveDir += 1;

            if (moveDir !== 0) {
              player.facing = moveDir;
              player.vx += moveDir * MOVE_ACCEL * dt;
            } else {
              player.vx *= FRICTION;
            }

            if (player.vx > MAX_SPEED) player.vx = MAX_SPEED;
            if (player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;

            // Jump
            if (keys.jump && player.onGround) {
              player.vy = JUMP_VELOCITY;
              player.onGround = false;
            }

            // Gravity
            player.vy += GRAVITY * dt;

            const res = rectVsTileCollision(
              player.x,
              player.y,
              PLAYER_W,
              PLAYER_H,
              player.vx,
              player.vy,
              dt
            );
            player.x = res.x;
            player.y = res.y;
            player.vx = res.vx;
            player.vy = res.vy;
            player.onGround = res.onGround;

            const checks = checkHazardsAndStars(player.x, player.y, PLAYER_W, PLAYER_H);
            if (checks.hazardHit && !gameWon) {
              showMessage("Hazard hit. Respawning‚Ä¶");
              respawn();
            }

            if (checks.portalHit && collectedStars >= totalStars && !gameWon) {
              gameWon = true;
              showMessage(
                "Portal reached with full quorum. You‚Äôve stabilized the Petroid sector."
              );
              updateHud("Beacon online");
            } else if (checks.portalHit && !gameWon) {
              showMessage(
                "Portal detected, but quorum is low. Stars collected: " +
                  collectedStars +
                  " / " +
                  totalStars +
                  "."
              );
            }
          }

          updateCamera();
        }

        function render() {
          drawWorld();
          drawPlayer();

          // Simple foreground stars tied to camera
          ctx.save();
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = "#9ca3af";
          for (let i = 0; i < 40; i++) {
            const sx = ((i * 137 + cameraX * 0.3) % canvas.width);
            const sy = (i * 59) % canvas.height;
            ctx.fillRect(sx, sy, 2, 2);
          }
          ctx.restore();

          // Top-left HUD inside canvas
          ctx.save();
          ctx.fillStyle = "rgba(15,23,42,0.75)";
          ctx.fillRect(8, 8, 210, 40);
          ctx.fillStyle = "#e5e7eb";
          ctx.font = "12px sans-serif";
          ctx.textAlign = "left";
          ctx.fillText(
            "Stars: " + collectedStars + " / " + totalStars,
            14,
            23
          );
          ctx.fillText("Sector: " + sectorName, 14, 38);
          ctx.restore();
        }

        // Start
        setForm("dog");
        respawn();
        requestAnimationFrame(step);
      })();
    });
  </script>
</body>
</html>
