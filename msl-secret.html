<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MSL: Petriod Protocol – Secret Sector</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="icon" type="image/png" href="logo-1.png" />

  <style>
    body.secret-page {
      background: radial-gradient(circle at top, #020617 0, #020617 30%, #000 100%);
      color: #f9fafb;
    }

    .secret-page .section {
      padding-top: 3rem;
      padding-bottom: 3rem;
    }

    .secret-page h1,
    .secret-page h2,
    .secret-page h3 {
      color: #f9fafb;
    }

    .secret-layout {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    @media (min-width: 960px) {
      .secret-layout {
        flex-direction: row;
        align-items: flex-start;
      }
      .secret-info {
        flex: 1;
        max-width: 320px;
      }
      .secret-card {
        flex: 2;
      }
    }

    .secret-info {
      padding: 1.25rem 1.5rem;
      border-radius: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.9);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.8);
      font-size: 0.9rem;
    }

    .secret-info h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
    }

    .secret-info ul {
      padding-left: 1.1rem;
      margin-top: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .secret-info li {
      margin-bottom: 0.35rem;
    }

    .secret-page .card.plain-card.secret-card {
      background: rgba(15, 23, 42, 0.95);
      border-radius: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.9);
    }

    .canvas-shell.secret-shell {
      background: #020617;
      border-radius: 0.9rem;
      padding: 0.6rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
    }

    .canvas-shell.secret-shell canvas {
      background: #020617;
      display: block;
      margin: 0 auto;
      max-width: 100%;
      border-radius: 0.6rem;
    }

    .controls-text {
      font-size: 0.8rem;
      opacity: 0.85;
      margin-top: 0.5rem;
    }

    #secretStatus {
      font-size: 0.8rem;
      margin-top: 0.35rem;
      min-height: 1.2em;
      color: #e5e7eb;
    }

    /* Intro overlay */
    .secret-intro {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background:
        radial-gradient(circle at top, rgba(15, 23, 42, 0.95) 0, rgba(2, 6, 23, 1) 40%, #000 100%);
      color: #e5e7eb;
      text-align: center;
      z-index: 50;
      pointer-events: none;
      opacity: 1;
      transition: opacity 1.5s ease-out 2.5s;
    }

    .secret-intro.hidden {
      opacity: 0;
    }

    .secret-intro h1 {
      font-size: 1.6rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      margin-bottom: 0.5rem;
    }

    .secret-intro p {
      font-size: 0.9rem;
      max-width: 420px;
      margin: 0.2rem auto;
      opacity: 0.9;
    }

    .secret-intro .scanline {
      width: 220px;
      height: 1px;
      margin: 1rem auto 0.5rem;
      background: linear-gradient(to right, transparent, #38bdf8, transparent);
      opacity: 0.8;
    }

    .secret-intro .tagline {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: #9ca3af;
    }

    .secret-intro .starfield {
      position: absolute;
      inset: 0;
      background-image:
        radial-gradient(2px 2px at 20% 20%, rgba(248, 250, 252, 0.7), transparent),
        radial-gradient(1.5px 1.5px at 70% 40%, rgba(248, 250, 252, 0.7), transparent),
        radial-gradient(2px 2px at 40% 80%, rgba(248, 250, 252, 0.7), transparent);
      opacity: 0.15;
      pointer-events: none;
    }

    /* Small HUD overlay for canvas text */
    .secret-hud-overlay {
      position: absolute;
      top: 0.75rem;
      left: 1rem;
      right: 1rem;
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #e5e7eb;
      text-shadow: 0 1px 2px #020617;
      pointer-events: none;
    }

    .secret-hud-left,
    .secret-hud-right {
      display: flex;
      gap: 0.8rem;
      flex-wrap: wrap;
    }

    @media (max-width: 640px) {
      .secret-hud-overlay {
        font-size: 0.7rem;
      }
    }
  </style>
</head>
<body class="secret-page">
  <header class="site-header">
    <div class="inner">
      <a href="index.html#hero" class="brand">
        <span class="brand-mark brand-mark-logo">
          <img src="logo-1.png" alt="SMCM MSL logo" />
        </span>
        <span class="brand-text">
          <span class="brand-title">MSL</span>
          <span class="brand-sub">St. Mary’s College of Maryland Chapter</span>
        </span>
      </a>
      <button class="nav-toggle" id="navToggle" aria-label="Toggle navigation">☰</button>
      <nav class="nav" id="mainNav">
        <a href="index.html#hero">Home</a>
        <a href="index.html#maryland">About MSL</a>
        <a href="index.html#chapter">Our Chapter</a>
        <a href="index.html#journey">Your Journey</a>
        <a href="index.html#documents">Documents</a>
        <a href="executive-board.html">Exec Board</a>
        <a href="resources.html">Resources</a>
        <a href="bulletin.html">Bulletin</a>
        <a href="msl-game.html">Games</a>
        <a href="index.html#gallery">Gallery</a>
        <a href="index.html#contact">Join Us</a>
        <a href="msl-giving.html">GIVING TUESDAY CHAMPIONSHIP</a>
      </nav>
    </div>
  </header>

  <main>
    <section class="section">
      <div class="inner">
        <div class="section-header">
          <p class="eyebrow">Hidden Sector</p>
          <h1>MSL: Petriod Protocol</h1>
          <p class="section-body">
            You found the secret field. Guide the Petriod unit through three sectors, collect data cores,
            pick up an upgrade, open the energy door, and reach the exit portal. Keyboard is required.
          </p>
        </div>

        <div class="secret-layout">
          <aside class="secret-info">
            <h2>Sector Notes</h2>
            <ul>
              <li><strong>Alpha:</strong> Warm-up jumps and early data cores.</li>
              <li><strong>Beta:</strong> Platform work and a vertical climb.</li>
              <li><strong>Gamma:</strong> Door, final stretch, and exit portal.</li>
            </ul>
            <p class="small">
              <strong>Controls:</strong> A / D or ← / → to move · W / ↑ / Space to jump ·
              J to fire an energy shot · R to restart the run.
            </p>
            <p class="small">
              Pick up the upgrade to enable a double jump. Hit the energy door with a shot, then push to
              the far right to reach the portal. Health is limited, but spikes are less unforgiving now.
            </p>
          </aside>

          <article class="card plain-card secret-card">
            <div class="canvas-shell secret-shell" style="position: relative;">
              <canvas id="secretCanvas" width="900" height="420"></canvas>
              <div class="secret-hud-overlay" id="secretHud">
                <div class="secret-hud-left">
                  <span id="hudSector"></span>
                  <span id="hudCores"></span>
                </div>
                <div class="secret-hud-right">
                  <span id="hudHealth"></span>
                </div>
              </div>
            </div>
            <p class="controls-text">
              Keyboard only: A / D or ← / → to move · W / ↑ / Space to jump · J to fire · R to reset.
            </p>
            <p id="secretStatus" class="small"></p>
          </article>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="inner footer-inner">
      <p>© <span id="year"></span> Maryland Student Legislature – St. Mary’s College of Maryland Chapter.</p>
      <p class="small">
        Student-led, nonpartisan, and rooted in Maryland’s civic life. This site is maintained by the SMCM
        Maryland Student Legislature Chapter and is not an official publication of St. Mary’s College of
        Maryland or the State of Maryland.
      </p>
    </div>
  </footer>

  <!-- Galaxy-style intro -->
  <div id="secretIntro" class="secret-intro">
    <div class="starfield"></div>
    <h1>PETRIOD PROTOCOL</h1>
    <div class="scanline"></div>
    <p>Booting hidden field simulator…</p>
    <p>Deploying unit to Alpha sector. Remain adaptive.</p>
    <p class="tagline">MSL • SIMULATION CHAMBER</p>
  </div>

  <script src="script.js"></script>

  <script>
    // Fade the intro after load
    window.addEventListener("load", function () {
      const intro = document.getElementById("secretIntro");
      if (!intro) return;
      setTimeout(() => {
        intro.classList.add("hidden");
      }, 3500);
    });

    document.addEventListener("DOMContentLoaded", function () {
      const canvas = document.getElementById("secretCanvas");
      const statusEl = document.getElementById("secretStatus");
      const hudSector = document.getElementById("hudSector");
      const hudCores = document.getElementById("hudCores");
      const hudHealth = document.getElementById("hudHealth");

      if (!canvas || !statusEl) return;
      const ctx = canvas.getContext("2d");

      const tileSize = 40;
      const rows = 16;
      const cols = 40;
      const worldWidth = cols * tileSize;
      const worldHeight = rows * tileSize;

      // Map layout ('.' is empty)
      const mapRows = [
        "........................................",
        "........................................",
        "........................................",
        "........................................",
        "........................................",
        "........................................",
        "........................................",
        "...........................*.....S......",
        ".........................#####..........",
        "...............*........................",
        "............######......................",
        "......*...........................##....",
        "....####..........................##....",
        "..P.............................##..D.E.",
        "..^^^.....^^^.....^^^.....^^^.##........",
        "########################################"
      ];

      const solids = [];
      const spikes = [];
      const stars = [];
      let suit = null;
      let door = null;
      let portal = null;
      const playerStart = { x: 0, y: 0 };

      for (let y = 0; y < rows; y++) {
        const row = mapRows[y];
        for (let x = 0; x < cols; x++) {
          const ch = row[x];
          const worldX = x * tileSize;
          const worldY = y * tileSize;

          if (ch === "#") {
            solids.push({ x: worldX, y: worldY, w: tileSize, h: tileSize });
          } else if (ch === "^") {
            // Narrow spike hitbox so it's less brutal
            spikes.push({
              x: worldX + 10,
              y: worldY + 16,
              w: tileSize - 20,
              h: tileSize - 20
            });
          } else if (ch === "*") {
            stars.push({
              x: worldX + tileSize / 2,
              y: worldY + tileSize / 2,
              collected: false
            });
          } else if (ch === "S") {
            suit = {
              x: worldX + tileSize / 2,
              y: worldY + tileSize / 2,
              taken: false
            };
          } else if (ch === "D") {
            door = {
              x: worldX,
              y: worldY,
              w: tileSize,
              h: tileSize,
              unlocked: false
            };
            solids.push(door);
          } else if (ch === "E") {
            portal = { x: worldX, y: worldY, w: tileSize, h: tileSize };
          } else if (ch === "P") {
            playerStart.x = worldX + tileSize / 2;
            playerStart.y = worldY + tileSize - 4;
          }
        }
      }

      const player = {
        x: playerStart.x,
        y: playerStart.y,
        w: 26,
        h: 32,
        vx: 0,
        vy: 0,
        onGround: false,
        facing: 1,
        canDoubleJump: false,
        usedDoubleJump: false
      };

      let health = 3;
      const maxHealth = 3;
      let collectedStars = 0;
      const totalStars = stars.length;

      let cameraX = 0;
      let gameWon = false;
      let gameOver = false;
      let damageCooldown = 0;

      const heroImage = new Image();
      heroImage.src = "petriod-core.jpg";
      let heroReady = false;
      heroImage.onload = function () {
        heroReady = true;
      };

      const bgImage = new Image();
      bgImage.src = "secret-bg-alpha.jpg";
      let bgReady = false;
      bgImage.onload = function () {
        bgReady = true;
      };

      const bullets = [];
      const BULLET_SPEED = 7;

      const keys = {};
      let jumpWasDown = false;

      window.addEventListener("keydown", function (e) {
        const key = e.key.toLowerCase();
        keys[key] = true;
        if (e.key === " " || e.code === "Space") {
          keys["space"] = true;
        }

        if (key === "j" || key === "f") {
          fireBullet();
        }
        if (key === "r") {
          resetGame();
        }
      });

      window.addEventListener("keyup", function (e) {
        const key = e.key.toLowerCase();
        keys[key] = false;
        if (e.key === " " || e.code === "Space") {
          keys["space"] = false;
        }
      });

      function getPlayerRect(x, y) {
        return {
          x: x - player.w / 2,
          y: y - player.h,
          w: player.w,
          h: player.h
        };
      }

      function rectsIntersect(a, b) {
        return (
          a.x < b.x + b.w &&
          a.x + a.w > b.x &&
          a.y < b.y + b.h &&
          a.y + a.h > b.y
        );
      }

      function resetGame() {
        player.x = playerStart.x;
        player.y = playerStart.y;
        player.vx = 0;
        player.vy = 0;
        player.onGround = false;
        player.facing = 1;
        player.canDoubleJump = false;
        player.usedDoubleJump = false;

        health = maxHealth;
        damageCooldown = 0;

        collectedStars = 0;
        stars.forEach(s => (s.collected = false));

        if (suit) {
          suit.taken = false;
        }

        if (door) {
          door.unlocked = false;
          if (!solids.includes(door)) {
            solids.push(door);
          }
        }

        cameraX = 0;
        gameWon = false;
        gameOver = false;
        statusEl.textContent = "";
      }

      function fireBullet() {
        if (gameWon || gameOver) return;
        const dir = player.facing || 1;
        const startRect = getPlayerRect(player.x, player.y);
        bullets.push({
          x: player.x + dir * (player.w / 2 + 6),
          y: startRect.y + player.h / 2,
          vx: dir * BULLET_SPEED
        });
      }

      function updateHud() {
        const px = Math.max(0, Math.min(player.x, worldWidth));
        const alphaLimit = worldWidth / 3;
        const betaLimit = (worldWidth * 2) / 3;
        let sector = "Alpha";
        if (px > betaLimit) {
          sector = "Gamma";
        } else if (px > alphaLimit) {
          sector = "Beta";
        }

        if (hudSector) {
          hudSector.textContent = "Sector: " + sector;
        }
        if (hudCores) {
          hudCores.textContent = "Cores: " + collectedStars + " / " + totalStars;
        }
        if (hudHealth) {
          const heartsFull = "♥".repeat(health);
          const heartsEmpty = "♡".repeat(maxHealth - health);
          hudHealth.textContent = "Health: " + heartsFull + heartsEmpty;
        }
      }

      function handleMovement() {
        if (gameWon || gameOver) return;

        const left = keys["a"] || keys["arrowleft"];
        const right = keys["d"] || keys["arrowright"];
        let move = 0;
        if (left) move -= 1;
        if (right) move += 1;

        const moveSpeed = 3;
        player.vx = move * moveSpeed;
        if (move !== 0) {
          player.facing = move;
        }

        const jumpPressed = keys["w"] || keys["arrowup"] || keys["space"];
        if (jumpPressed && !jumpWasDown) {
          if (player.onGround) {
            player.vy = -9;
            player.onGround = false;
            player.usedDoubleJump = false;
          } else if (player.canDoubleJump && !player.usedDoubleJump) {
            player.vy = -9;
            player.usedDoubleJump = true;
          }
        }
        jumpWasDown = jumpPressed;

        // Gravity
        player.vy += 0.45;
        if (player.vy > 10) player.vy = 10;

        // Horizontal movement + collision
        let newX = player.x + player.vx;
        let rect = getPlayerRect(newX, player.y);
        for (let i = 0; i < solids.length; i++) {
          const s = solids[i];
          if (rectsIntersect(rect, s)) {
            if (player.vx > 0) {
              rect.x = s.x - rect.w;
              newX = rect.x + player.w / 2;
            } else if (player.vx < 0) {
              rect.x = s.x + s.w;
              newX = rect.x + player.w / 2;
            }
            player.vx = 0;
          }
        }
        player.x = newX;

        // Vertical movement + collision
        let newY = player.y + player.vy;
        let vRect = getPlayerRect(player.x, newY);
        player.onGround = false;
        for (let i = 0; i < solids.length; i++) {
          const s = solids[i];
          if (rectsIntersect(vRect, s)) {
            if (player.vy > 0) {
              vRect.y = s.y - vRect.h;
              newY = vRect.y + player.h;
              player.onGround = true;
            } else if (player.vy < 0) {
              vRect.y = s.y + s.h;
              newY = vRect.y + player.h;
            }
            player.vy = 0;
          }
        }
        player.y = newY;

        // Clamp within world bounds
        if (player.x < player.w / 2) player.x = player.w / 2;
        if (player.x > worldWidth - player.w / 2) {
          player.x = worldWidth - player.w / 2;
        }
        if (player.y > worldHeight) {
          // Fell out of the map – treat as damage
          applyDamage(true);
        }

        // Camera follow
        const halfWidth = canvas.width / 2;
        cameraX = player.x - halfWidth;
        if (cameraX < 0) cameraX = 0;
        if (cameraX > worldWidth - canvas.width) {
          cameraX = worldWidth - canvas.width;
        }
      }

      function applyDamage(fromFall) {
        if (damageCooldown > 0 || gameWon || gameOver) return;
        health -= 1;
        damageCooldown = 60; // ~1 second of grace

        if (health <= 0) {
          gameOver = true;
          statusEl.textContent = fromFall
            ? "System failure: impact too great. Press R to reboot."
            : "System failure: integrity depleted. Press R to reboot.";
          return;
        }

        player.vy = -7;
        if (fromFall) {
          statusEl.textContent = "System warning: impact damage detected.";
        } else {
          statusEl.textContent = "System warning: contact with hazard detected.";
        }
      }

      function handleHazardsAndItems() {
        const pRect = getPlayerRect(player.x, player.y);

        if (damageCooldown > 0) {
          damageCooldown -= 1;
        }

        // Spikes
        for (let i = 0; i < spikes.length; i++) {
          if (rectsIntersect(pRect, spikes[i])) {
            applyDamage(false);
            break;
          }
        }

        // Stars
        for (let i = 0; i < stars.length; i++) {
          const s = stars[i];
          if (s.collected) continue;
          const dx = player.x - s.x;
          const dy = (player.y - player.h / 2) - s.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 20) {
            s.collected = true;
            collectedStars += 1;
            statusEl.textContent = "Core acquired. Cores: " + collectedStars + " / " + totalStars + ".";
          }
        }

        // Suit pickup
        if (suit && !suit.taken) {
          const dx = player.x - suit.x;
          const dy = (player.y - player.h / 2) - suit.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 24) {
            suit.taken = true;
            player.canDoubleJump = true;
            statusEl.textContent = "Upgrade installed: double jump online.";
          }
        }

        // Portal
        if (portal && !gameWon) {
          if (rectsIntersect(pRect, portal)) {
            gameWon = true;
            if (collectedStars === totalStars) {
              statusEl.textContent =
                "Portal reached with all cores recovered. Simulation complete.";
            } else {
              statusEl.textContent =
                "Portal reached. Simulation complete. Some cores remain for a 100% run.";
            }
          }
        }
      }

      function handleBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.x += b.vx;

          const bRect = { x: b.x - 4, y: b.y - 4, w: 8, h: 8 };

          let remove = false;

          // Door interaction
          if (door && !door.unlocked && rectsIntersect(bRect, door)) {
            door.unlocked = true;
            const idx = solids.indexOf(door);
            if (idx !== -1) solids.splice(idx, 1);
            statusEl.textContent = "Energy lock disengaged. Door cleared.";
            remove = true;
          }

          // World bounds
          if (b.x < -50 || b.x > worldWidth + 50) {
            remove = true;
          }

          if (remove) {
            bullets.splice(i, 1);
          }
        }
      }

      function drawBackground() {
        if (bgReady) {
          ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
        } else {
          const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
          grad.addColorStop(0, "#020617");
          grad.addColorStop(1, "#000000");
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }

      function drawWorld() {
        ctx.save();
        ctx.translate(-cameraX, 0);

        // Solids
        ctx.fillStyle = "#020617";
        ctx.strokeStyle = "#4b5563";
        ctx.lineWidth = 1.2;
        solids.forEach(s => {
          ctx.fillRect(s.x, s.y, s.w, s.h);
          ctx.strokeRect(s.x, s.y, s.w, s.h);
        });

        // Door visuals
        if (door) {
          ctx.save();
          if (door.unlocked) {
            ctx.strokeStyle = "#22c55e";
          } else {
            ctx.strokeStyle = "#f97316";
          }
          ctx.lineWidth = 2;
          ctx.strokeRect(door.x + 4, door.y + 4, door.w - 8, door.h - 8);
          ctx.restore();
        }

        // Spikes
        ctx.fillStyle = "#f97316";
        spikes.forEach(sp => {
          ctx.beginPath();
          const baseY = sp.y + sp.h;
          const centerX = sp.x + sp.w / 2;
          ctx.moveTo(sp.x, baseY);
          ctx.lineTo(centerX, sp.y);
          ctx.lineTo(sp.x + sp.w, baseY);
          ctx.closePath();
          ctx.fill();
        });

        // Stars (cores)
        stars.forEach(s => {
          if (s.collected) return;
          ctx.fillStyle = "#facc15";
          ctx.beginPath();
          ctx.arc(s.x, s.y, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#fbbf24";
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        // Suit
        if (suit && !suit.taken) {
          ctx.save();
          ctx.translate(suit.x, suit.y);
          ctx.fillStyle = "#38bdf8";
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#e0f2fe";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        }

        // Portal
        if (portal) {
          ctx.save();
          ctx.translate(portal.x + portal.w / 2, portal.y + portal.h / 2);
          const r = 14;
          const grd = ctx.createRadialGradient(0, 0, 2, 0, 0, r);
          grd.addColorStop(0, "#e0f2fe");
          grd.addColorStop(1, "#6366f1");
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Bullets
        bullets.forEach(b => {
          ctx.fillStyle = "#38bdf8";
          ctx.beginPath();
          ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
          ctx.fill();
        });

        // Player
        const pRect = getPlayerRect(player.x, player.y);
        if (heroReady) {
          ctx.save();
          ctx.translate(player.x, pRect.y + player.h / 2);
          ctx.scale(player.facing < 0 ? -1 : 1, 1);
          ctx.drawImage(
            heroImage,
            -player.w / 2,
            -player.h / 2,
            player.w,
            player.h
          );
          ctx.restore();
        } else {
          ctx.fillStyle = "#38bdf8";
          ctx.fillRect(pRect.x, pRect.y, pRect.w, pRect.h);
        }

        ctx.restore();
      }

      function draw() {
        drawBackground();
        drawWorld();
      }

      function loop() {
        handleMovement();
        handleHazardsAndItems();
        handleBullets();
        updateHud();
        draw();
        requestAnimationFrame(loop);
      }

      resetGame();
      loop();
    });
  </script>
</body>
</html>
