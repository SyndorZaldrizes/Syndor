<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MSL: Petriod Protocol – Secret Sector</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="icon" type="image/png" href="logo-1.png" />

  <style>
    body.secret-page {
      background: radial-gradient(circle at top, #020617, #020617 35%, #000 100%);
      color: #e5e7eb;
    }

    .secret-page .section {
      padding-top: 3rem;
      padding-bottom: 3rem;
    }

    .secret-page h1,
    .secret-page h2,
    .secret-page h3 {
      color: #f9fafb;
    }

    .secret-notes {
      background: rgba(15, 23, 42, 0.95);
      border-radius: 1rem;
      padding: 1.25rem 1.5rem;
      border: 1px solid rgba(148, 163, 184, 0.6);
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.9);
      margin-bottom: 1.75rem;
    }

    .secret-notes h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
    }

    .secret-notes ul {
      margin: 0.35rem 0 0.75rem;
      padding-left: 1.1rem;
    }

    .secret-notes li {
      font-size: 0.9rem;
      margin-bottom: 0.2rem;
    }

    .secret-notes p {
      font-size: 0.85rem;
      margin: 0.25rem 0;
    }

    .secret-card {
      background: radial-gradient(circle at top, #020617, #020617 55%, #000 100%);
      border-radius: 1.25rem;
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.95);
      padding: 1.5rem 1.75rem 1.5rem;
      max-width: 1100px;
      margin: 0 auto;
    }

    .secret-card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }

    .secret-card-header h2 {
      font-size: 1.3rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .secret-tag {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      opacity: 0.85;
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
    }

    .secret-shell {
      margin-top: 0.5rem;
      border-radius: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: radial-gradient(circle at top, #020617, #020617 70%, #000 100%);
      padding: 0.75rem;
    }

    .secret-shell canvas {
      display: block;
      margin: 0 auto;
      background: #020617;
      border-radius: 0.75rem;
      max-width: 100%;
      width: 100%;
      height: auto;
    }

    .secret-hud {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 0.6rem;
      font-size: 0.8rem;
      margin-top: 0.5rem;
      color: #e5e7eb;
    }

    .secret-hud span {
      opacity: 0.9;
    }

    .secret-status {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      min-height: 1.2em;
      color: #e5e7eb;
      opacity: 0.9;
    }

    .secret-controls-text {
      margin-top: 0.75rem;
      font-size: 0.8rem;
      opacity: 0.85;
    }

    @media (max-width: 768px) {
      .secret-card {
        padding: 1.25rem 1.1rem;
      }
      .secret-shell {
        padding: 0.5rem;
      }
      .secret-card-header h2 {
        font-size: 1.1rem;
      }
    }
  </style>
</head>

<body class="secret-page">
  <header class="site-header">
    <div class="inner">
      <a href="index.html#hero" class="brand">
        <span class="brand-mark brand-mark-logo">
          <img src="logo-1.png" alt="SMCM MSL logo" />
        </span>
        <span class="brand-text">
          <span class="brand-title">Maryland Student Legislature</span>
          <span class="brand-sub">St. Mary’s College of Maryland Chapter</span>
        </span>
      </a>
      <button class="nav-toggle" id="navToggle" aria-label="Toggle navigation">☰</button>
      <nav class="nav" id="mainNav">
        <a href="index.html#hero">Home</a>
        <a href="index.html#maryland">About MSL</a>
        <a href="index.html#chapter">Our Chapter</a>
        <a href="index.html#journey">Your Journey</a>
        <a href="index.html#documents">Documents</a>
        <a href="executive-board.html">Exec Board</a>
        <a href="resources.html">Resources</a>
        <a href="bulletin.html">Bulletin</a>
        <a href="msl-game.html">Games</a>
        <a href="index.html#gallery">Gallery</a>
        <a href="index.html#contact">Join Us</a>
        <a href="msl-giving.html">GIVING TUESDAY CHAMPIONSHIP</a>
      </nav>
    </div>
  </header>

  <main>
    <section class="section">
      <div class="inner">
        <div class="section-header">
          <p class="eyebrow">Hidden Sector</p>
          <h1>MSL: Petriod Protocol</h1>
          <p class="section-body">
            You found the secret field. Guide the Petriod unit through three sectors, collect data cores,
            pick up an upgrade, neutralize hostiles, and reach the exit portal. Keyboard required.
          </p>
        </div>

        <!-- Sector notes ABOVE the game -->
        <div class="secret-notes">
          <h2>Sector Notes</h2>
          <ul>
            <li><strong>Alpha:</strong> Tutorial sector – movement, jumps, cores, and the mobility upgrade.</li>
            <li><strong>Beta:</strong> Wider platforms and patrolling hostiles.</li>
            <li><strong>Gamma:</strong> Final corridor with hazards, hostiles, and the exit portal.</li>
          </ul>
          <p>
            Controls: <strong>A / D</strong> or <strong>← / →</strong> to move ·
            <strong>W / ↑ / Space</strong> to jump (double jump after upgrade) ·
            <strong>J</strong> to fire · <strong>R</strong> to restart from Sector Alpha.
          </p>
        </div>

        <!-- Game card -->
        <article class="card plain-card secret-card">
          <div class="secret-card-header">
            <h2>Petriod Protocol</h2>
            <span class="secret-tag">Simulation Chamber</span>
          </div>
          <p class="small" style="margin-bottom: 0.75rem;">
            Deploy the Petriod core into the field, collect data, and survive long enough to reach the portal.
          </p>

          <div class="secret-shell">
            <canvas id="petriodCanvas" width="900" height="420"></canvas>
            <div class="secret-hud">
              <span id="hud-sector">Sector: Alpha</span>
              <span id="hud-cores">Cores: 0 / 0</span>
              <span id="hud-health">Integrity: ♥♥♥</span>
              <span id="hud-level">Stage: 1 / 3</span>
            </div>
            <div id="hud-status" class="secret-status"></div>
          </div>

          <p class="secret-controls-text">
            Keyboard only: A / D or ← / → to move · W / ↑ / Space to jump · J to fire · R to reset.
          </p>
        </article>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="inner footer-inner">
      <p>© <span id="year"></span> Maryland Student Legislature – St. Mary’s College of Maryland Chapter.</p>
      <p class="small">
        Student-led, nonpartisan, and rooted in Maryland’s civic life. This site is maintained by the SMCM
        Maryland Student Legislature Chapter and is not an official publication of St. Mary’s College of
        Maryland or the State of Maryland.
      </p>
    </div>
  </footer>

  <script src="script.js"></script>

  <!-- Petriod Protocol game logic -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const canvas = document.getElementById("petriodCanvas");
      if (!canvas || !canvas.getContext) return;
      const ctx = canvas.getContext("2d");

      const TILE = 40;
      const COLS = 60;  // wider world → more horizontal space, same zoom
      const ROWS = 16;
      const WORLD_WIDTH = COLS * TILE;
      const WORLD_HEIGHT = ROWS * TILE;

      // HUD elements
      const hudSector = document.getElementById("hud-sector");
      const hudCores = document.getElementById("hud-cores");
      const hudHealth = document.getElementById("hud-health");
      const hudLevel = document.getElementById("hud-level");
      const hudStatus = document.getElementById("hud-status");

      // Player (small, Metroid-style relative to world)
      const player = {
        x: 0,
        y: 0,
        w: 18,
        h: 28,
        vx: 0,
        vy: 0,
        onGround: false,
        facing: 1,
        maxHealth: 3,
        health: 3,
        canDouble: false,
        jumpCount: 0,
        invuln: 0
      };

      // World objects
      let solids = [];
      let spikes = [];
      let stars = [];
      let enemies = [];
      let suit = null;
      let portal = null;
      let shots = [];
      let cameraX = 0;

      // Inputs
      const keys = { left: false, right: false };
      let jumpQueued = false;
      let shootQueued = false;

      // State
      let currentLevelIndex = 0;
      let totalStarsAll = 0;
      let collectedStarsTotal = 0;
      let gameOver = false;
      let gameWon = false;
      let shotCooldown = 0;
      let introTime = 0;
      let lastTime = 0;

      // Backgrounds (optional; if missing, gradient is used)
      const bgImages = [];

      // Simple starfield
      let starField = [];
      function makeStarField() {
        starField = [];
        for (let i = 0; i < 70; i++) {
          starField.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            r: Math.random() * 1.8 + 0.4,
            speed: Math.random() * 0.4 + 0.2
          });
        }
      }

      function updateStarField(dt) {
        for (const star of starField) {
          star.y += star.speed;
          if (star.y > canvas.height) {
            star.y = -5;
            star.x = Math.random() * canvas.width;
          }
        }
      }

      function drawStarField() {
        for (const star of starField) {
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(248, 250, 252, 0.8)";
          ctx.fill();
        }
      }

      // Map helpers
      function createEmptyGrid() {
        return Array.from({ length: ROWS }, () => Array(COLS).fill("."));
      }

      function buildAlpha() {
        const g = createEmptyGrid();
        // Base floor
        for (let c = 0; c < COLS; c++) g[ROWS - 1][c] = "#";

        // Platforms
        for (let c = 4; c <= 10; c++) g[11][c] = "#";
        for (let c = 18; c <= 24; c++) g[9][c] = "#";
        for (let c = 34; c <= 42; c++) g[7][c] = "#";

        // Spikes near floor (with gaps)
        for (let c = 8; c <= 11; c++) g[14][c] = "^";
        for (let c = 26; c <= 29; c++) g[14][c] = "^";
        for (let c = 44; c <= 47; c++) g[14][c] = "^";

        // Stars (data cores)
        g[13][6] = "*";
        g[10][20] = "*";
        g[6][38] = "*";

        // Suit (double jump upgrade)
        g[10][33] = "S";

        // Player start & portal
        g[13][3] = "P";
        g[13][55] = "E";

        return g.map(row => row.join(""));
      }

      function buildBeta() {
        const g = createEmptyGrid();
        // Base floor
        for (let c = 0; c < COLS; c++) g[ROWS - 1][c] = "#";

        // Platforms
        for (let c = 10; c <= 18; c++) g[12][c] = "#";
        for (let c = 26; c <= 35; c++) g[9][c] = "#";
        for (let c = 40; c <= 52; c++) g[6][c] = "#";

        // Stars
        g[11][14] = "*";
        g[8][30] = "*";
        g[5][45] = "*";

        // Enemies
        g[14][20] = "X";
        g[14][40] = "X";

        // Player start & portal
        g[13][3] = "P";
        g[13][55] = "E";

        return g.map(row => row.join(""));
      }

      function buildGamma() {
        const g = createEmptyGrid();
        // Base floor
        for (let c = 0; c < COLS; c++) g[ROWS - 1][c] = "#";

        // High platforms
        for (let c = 14; c <= 20; c++) g[11][c] = "#";
        for (let c = 34; c <= 40; c++) g[11][c] = "#";

        // Spikes
        for (let c = 8; c <= 11; c++) g[14][c] = "^";
        for (let c = 24; c <= 27; c++) g[14][c] = "^";
        for (let c = 40; c <= 43; c++) g[14][c] = "^";

        // Stars
        g[9][16] = "*";
        g[9][38] = "*";

        // Enemies
        g[14][18] = "X";
        g[14][38] = "X";

        // Player start & portal
        g[13][3] = "P";
        g[13][55] = "E";

        return g.map(row => row.join(""));
      }

      const LEVELS = [
        { name: "Alpha", bg: "secret-bg-alpha.jpg", buildMap: buildAlpha },
        { name: "Beta", bg: "secret-bg-beta.jpg", buildMap: buildBeta },
        { name: "Gamma", bg: "secret-bg-gamma.jpg", buildMap: buildGamma }
      ];

      // Preload backgrounds & count stars
      LEVELS.forEach((level, idx) => {
        const img = new Image();
        img.src = level.bg;
        bgImages[idx] = img;

        const map = level.buildMap();
        let starsHere = 0;
        for (let r = 0; r < ROWS; r++) {
          const line = map[r];
          for (let c = 0; c < COLS; c++) {
            if (line[c] === "*") starsHere++;
          }
        }
        level.totalStars = starsHere;
        totalStarsAll += starsHere;
      });

      // Petriod core graphic (if present)
      const playerImg = new Image();
      playerImg.src = "petriod-core.jpg";

      function rectsIntersect(a, b) {
        return (
          a.x < b.x + b.w &&
          a.x + a.w > b.x &&
          a.y < b.y + b.h &&
          a.y + a.h > b.y
        );
      }

      function applyDamage(amount) {
        if (player.invuln > 0 || gameOver || gameWon) return;
        player.health -= amount;
        if (player.health <= 0) {
          player.health = 0;
          gameOver = true;
          if (hudStatus) hudStatus.textContent = "Shell integrity lost. Press R to redeploy to Alpha.";
        } else {
          player.invuln = 1.0;
          if (hudStatus) hudStatus.textContent = "Impact detected. Stabilizing...";
        }
        updateHud();
      }

      function updateHud() {
        const level = LEVELS[currentLevelIndex];
        if (hudSector) hudSector.textContent = "Sector: " + level.name;
        if (hudLevel) hudLevel.textContent = "Stage: " + (currentLevelIndex + 1) + " / " + LEVELS.length;
        if (hudCores) hudCores.textContent = "Cores: " + collectedStarsTotal + " / " + totalStarsAll;
        if (hudHealth) {
          const hearts = "♥".repeat(player.health) + "♡".repeat(player.maxHealth - player.health);
          hudHealth.textContent = "Integrity: " + hearts;
        }
      }

      function buildLevel(index, keepProgress) {
        currentLevelIndex = index;
        const level = LEVELS[index];
        const map = level.buildMap();

        solids = [];
        spikes = [];
        stars = [];
        enemies = [];
        shots = [];
        suit = null;
        portal = null;

        let startX = 80;
        let startY = TILE * (ROWS - 3);

        for (let row = 0; row < ROWS; row++) {
          const line = map[row];
          for (let col = 0; col < COLS; col++) {
            const ch = line[col];
            const x = col * TILE;
            const y = row * TILE;

            switch (ch) {
              case "#":
                solids.push({ x, y, w: TILE, h: TILE });
                break;
              case "^":
                spikes.push({
                  x,
                  y: y + TILE / 2,
                  w: TILE,
                  h: TILE / 2
                });
                break;
              case "*":
                stars.push({
                  x: x + TILE * 0.25,
                  y: y + TILE * 0.25,
                  w: TILE * 0.5,
                  h: TILE * 0.5,
                  collected: false
                });
                break;
              case "P":
                startX = x + TILE * 0.5;
                startY = y + TILE - player.h - 2;
                break;
              case "S":
                suit = { x, y, w: TILE, h: TILE, taken: false };
                break;
              case "E":
                portal = { x: x + TILE * 0.5, y: y + TILE * 0.5, r: 18 };
                break;
              case "X":
                enemies.push({
                  x: x + TILE * 0.5,
                  y: y + TILE - 20,
                  w: 20,
                  h: 20,
                  vx: Math.random() < 0.5 ? 1.2 : -1.2,
                  leftBound: x - TILE,
                  rightBound: x + TILE * 2,
                  alive: true
                });
                break;
              default:
                break;
            }
          }
        }

        if (!keepProgress) {
          player.health = player.maxHealth;
          player.canDouble = false;
          collectedStarsTotal = 0;
        }

        player.x = startX;
        player.y = startY;
        player.vx = 0;
        player.vy = 0;
        player.onGround = false;
        player.jumpCount = 0;
        player.invuln = 0;

        cameraX = Math.max(
          0,
          Math.min(player.x - canvas.width / 2, WORLD_WIDTH - canvas.width)
        );

        if (hudStatus) {
          hudStatus.textContent = keepProgress
            ? "Transitioned to " + level.name + " sector."
            : "Deploying unit to " + level.name + " sector. Remain adaptive.";
        }
        updateHud();
      }

      function startNewRun() {
        gameOver = false;
        gameWon = false;
        introTime = 0;
        buildLevel(0, false);
        makeStarField();
      }

      // Input handling
      window.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        const code = e.code;

        if (code === "ArrowLeft" || code === "KeyA") {
          keys.left = true;
        }
        if (code === "ArrowRight" || code === "KeyD") {
          keys.right = true;
        }
        if (code === "ArrowUp" || code === "KeyW" || code === "Space") {
          e.preventDefault();
          jumpQueued = true;
        }
        if (code === "KeyJ") {
          shootQueued = true;
        }
        if (code === "KeyR") {
          startNewRun();
        }
      });

      window.addEventListener("keyup", (e) => {
        const code = e.code;
        if (code === "ArrowLeft" || code === "KeyA") {
          keys.left = false;
        }
        if (code === "ArrowRight" || code === "KeyD") {
          keys.right = false;
        }
      });

      function performJump() {
        if (gameOver || gameWon) return;

        if (player.onGround) {
          player.vy = -11;
          player.onGround = false;
          player.jumpCount = 1;
        } else if (player.canDouble && player.jumpCount < 2) {
          player.vy = -10;
          player.jumpCount++;
        }
      }

      function createShot() {
        if (gameOver || gameWon) return;
        const dir = player.facing >= 0 ? 1 : -1;
        shots.push({
          x: player.x + (dir > 0 ? player.w : -8),
          y: player.y + player.h * 0.35,
          w: 8,
          h: 3,
          vx: dir * 9
        });
      }

      function updateShots(dt) {
        shotCooldown = Math.max(0, shotCooldown - dt);
        const next = [];
        for (const s of shots) {
          s.x += s.vx;

          if (s.x < -50 || s.x > WORLD_WIDTH + 50) continue;

          let destroyed = false;

          // Hit solids
          for (const solid of solids) {
            if (rectsIntersect(s, solid)) {
              destroyed = true;
              break;
            }
          }

          // Hit enemies
          if (!destroyed) {
            for (const enemy of enemies) {
              if (!enemy.alive) continue;
              if (rectsIntersect(s, enemy)) {
                enemy.alive = false;
                destroyed = true;
                if (hudStatus) hudStatus.textContent = "Hostile neutralized.";
                break;
              }
            }
          }

          if (!destroyed) next.push(s);
        }
        shots = next;
      }

      function updateEnemies(dt) {
        for (const e of enemies) {
          if (!e.alive) continue;
          e.x += e.vx;
          if (e.x < e.leftBound) {
            e.x = e.leftBound;
            e.vx *= -1;
          } else if (e.x + e.w > e.rightBound) {
            e.x = e.rightBound - e.w;
            e.vx *= -1;
          }
        }
      }

      function updatePlayer(dt) {
        if (gameOver || gameWon) return;

        const speed = 3.2;
        player.vx = 0;

        if (keys.left) {
          player.vx = -speed;
          player.facing = -1;
        } else if (keys.right) {
          player.vx = speed;
          player.facing = 1;
        }

        if (jumpQueued) {
          performJump();
          jumpQueued = false;
        }

        if (shootQueued && shotCooldown === 0) {
          createShot();
          shotCooldown = 0.2;
        }
        shootQueued = false;

        // Gravity
        player.vy += 0.55;
        if (player.vy > 16) player.vy = 16;

        // Horizontal movement & collisions
        player.x += player.vx;
        let rect = { x: player.x, y: player.y, w: player.w, h: player.h };

        for (const solid of solids) {
          if (rectsIntersect(rect, solid)) {
            if (player.vx > 0) {
              player.x = solid.x - player.w;
            } else if (player.vx < 0) {
              player.x = solid.x + solid.w;
            }
          }
        }

        // Vertical movement & collisions
        player.y += player.vy;
        player.onGround = false;
        rect = { x: player.x, y: player.y, w: player.w, h: player.h };

        for (const solid of solids) {
          if (rectsIntersect(rect, solid)) {
            if (player.vy > 0) {
              player.y = solid.y - player.h;
              player.vy = 0;
              player.onGround = true;
              player.jumpCount = 0;
            } else if (player.vy < 0) {
              player.y = solid.y + solid.h;
              player.vy = 0;
            }
          }
        }

        // World bounds
        if (player.x < 0) player.x = 0;
        if (player.x + player.w > WORLD_WIDTH) player.x = WORLD_WIDTH - player.w;
        if (player.y > WORLD_HEIGHT + 200) {
          applyDamage(player.maxHealth); // fall = fail
        }

        // Spikes
        const pRect = { x: player.x, y: player.y, w: player.w, h: player.h };
        for (const sp of spikes) {
          if (rectsIntersect(pRect, sp)) {
            applyDamage(1);
            break;
          }
        }

        // Enemies
        for (const e of enemies) {
          if (!e.alive) continue;
          const eRect = { x: e.x, y: e.y, w: e.w, h: e.h };
          if (rectsIntersect(pRect, eRect)) {
            applyDamage(1);
            break;
          }
        }

        // Suit pickup
        if (suit && !suit.taken) {
          const sRect = { x: suit.x, y: suit.y, w: suit.w, h: suit.h };
          if (rectsIntersect(pRect, sRect)) {
            suit.taken = true;
            player.canDouble = true;
            if (hudStatus) hudStatus.textContent = "Mobility upgrade acquired. Double jump online.";
          }
        }

        // Stars (cores)
        for (const star of stars) {
          if (star.collected) continue;
          if (rectsIntersect(pRect, star)) {
            star.collected = true;
            collectedStarsTotal++;
            if (hudStatus) hudStatus.textContent = "Data core secured.";
          }
        }

        // Portal / level transition
        if (portal && !gameOver && !gameWon) {
          const dx = player.x + player.w / 2 - portal.x;
          const dy = player.y + player.h / 2 - portal.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < portal.r + 8) {
            if (currentLevelIndex < LEVELS.length - 1) {
              buildLevel(currentLevelIndex + 1, true);
            } else {
              gameWon = true;
              const fullClear = collectedStarsTotal === totalStarsAll;
              if (hudStatus) {
                hudStatus.textContent = fullClear
                  ? "Protocol complete. All cores recovered."
                  : "Protocol complete. Some data cores remain for a perfect run.";
              }
            }
          }
        }

        // Camera: keep zoom, just scroll
        cameraX = player.x - canvas.width / 2;
        if (cameraX < 0) cameraX = 0;
        if (cameraX > WORLD_WIDTH - canvas.width) {
          cameraX = WORLD_WIDTH - canvas.width;
        }

        if (player.invuln > 0) {
          player.invuln -= dt;
          if (player.invuln < 0) player.invuln = 0;
        }

        updateHud();
      }

      function drawGame() {
        const level = LEVELS[currentLevelIndex];
        const bgImg = bgImages[currentLevelIndex];

        // Background
        if (bgImg && bgImg.complete) {
          ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
        } else {
          const g = ctx.createRadialGradient(
            canvas.width / 2,
            0,
            20,
            canvas.width / 2,
            canvas.height,
            canvas.height
          );
          g.addColorStop(0, "#020617");
          g.addColorStop(1, "#000000");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Starfield
        drawStarField();

        ctx.save();
        ctx.translate(-cameraX, 0);

        // Solids
        ctx.fillStyle = "#0f172a";
        for (const s of solids) {
          ctx.fillRect(s.x, s.y, s.w, s.h);
        }

        // Spikes
        ctx.fillStyle = "#f97316";
        for (const sp of spikes) {
          ctx.beginPath();
          const segments = 3;
          const step = sp.w / segments;
          for (let i = 0; i < segments; i++) {
            const x0 = sp.x + i * step;
            ctx.moveTo(x0, sp.y + sp.h);
            ctx.lineTo(x0 + step / 2, sp.y);
            ctx.lineTo(x0 + step, sp.y + sp.h);
          }
          ctx.closePath();
          ctx.fill();
        }

        // Stars
        for (const star of stars) {
          if (star.collected) continue;
          ctx.fillStyle = "#facc15";
          ctx.beginPath();
          const cx = star.x + star.w / 2;
          const cy = star.y + star.h / 2;
          const r = star.w / 2;
          for (let i = 0; i < 5; i++) {
            const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
            const x = cx + Math.cos(angle) * r;
            const y = cy + Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
        }

        // Suit
        if (suit && !suit.taken) {
          ctx.fillStyle = "#38bdf8";
          ctx.fillRect(suit.x + 6, suit.y + 6, suit.w - 12, suit.h - 12);
        }

        // Portal
        if (portal) {
          ctx.beginPath();
          ctx.arc(portal.x, portal.y, portal.r, 0, Math.PI * 2);
          const pGrad = ctx.createRadialGradient(
            portal.x,
            portal.y,
            4,
            portal.x,
            portal.y,
            portal.r
          );
          pGrad.addColorStop(0, "#a5b4fc");
          pGrad.addColorStop(1, "#4f46e5");
          ctx.fillStyle = pGrad;
          ctx.fill();
        }

        // Enemies
        for (const e of enemies) {
          if (!e.alive) continue;
          ctx.fillStyle = "#f97373";
          ctx.fillRect(e.x, e.y, e.w, e.h);
        }

        // Player
        ctx.save();
        ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
        if (player.facing < 0) ctx.scale(-1, 1);
        ctx.translate(-player.w / 2, -player.h / 2);

        const baseAlpha = player.invuln > 0 ? 0.6 : 1;
        ctx.globalAlpha = baseAlpha;
        ctx.fillStyle = "#e5e7eb";
        ctx.fillRect(0, 0, player.w, player.h);

        // Helmet
        ctx.fillStyle = "#38bdf8";
        ctx.fillRect(2, 2, player.w - 4, 9);

        // Core symbol
        if (playerImg.complete && playerImg.naturalWidth) {
          ctx.drawImage(playerImg, player.w / 2 - 5, player.h / 2 - 5, 10, 10);
        } else {
          ctx.fillStyle = "#0f172a";
          ctx.fillRect(player.w / 2 - 3, player.h / 2 - 3, 6, 6);
        }

        ctx.restore();

        // Shots
        ctx.fillStyle = "#facc15";
        for (const s of shots) {
          ctx.fillRect(s.x, s.y, s.w, s.h);
        }

        ctx.restore();

        // Overlays
        if (introTime < 2.5) {
          const alpha = Math.min(1, 2.5 - introTime);
          ctx.fillStyle = "rgba(15, 23, 42," + (0.7 * alpha) + ")";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "rgba(226, 232, 240," + alpha + ")";
          ctx.textAlign = "center";
          ctx.font = "22px system-ui, -apple-system, sans-serif";
          ctx.fillText("PETRIOD PROTOCOL", canvas.width / 2, canvas.height / 2 - 10);
          ctx.font = "12px system-ui, -apple-system, sans-serif";
          ctx.fillText("Booting hidden field simulator…", canvas.width / 2, canvas.height / 2 + 12);
        } else if (gameOver) {
          ctx.fillStyle = "rgba(15,23,42,0.8)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#f97373";
          ctx.textAlign = "center";
          ctx.font = "18px system-ui, -apple-system, sans-serif";
          ctx.fillText("Simulation failure.", canvas.width / 2, canvas.height / 2 - 6);
          ctx.font = "12px system-ui, -apple-system, sans-serif";
          ctx.fillStyle = "#e5e7eb";
          ctx.fillText("Press R to redeploy from Alpha.", canvas.width / 2, canvas.height / 2 + 12);
        } else if (gameWon) {
          ctx.fillStyle = "rgba(15,23,42,0.78)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#4ade80";
          ctx.textAlign = "center";
          ctx.font = "18px system-ui, -apple-system, sans-serif";
          ctx.fillText("Protocol complete.", canvas.width / 2, canvas.height / 2 - 6);
          ctx.font = "12px system-ui, -apple-system, sans-serif";
          ctx.fillStyle = "#e5e7eb";
          ctx.fillText("Press R to run it again for a cleaner record.", canvas.width / 2, canvas.height / 2 + 12);
        }
      }

      function loop(timestamp) {
        const dt = (timestamp - (lastTime || timestamp)) / 1000;
        lastTime = timestamp;
        introTime += dt;
        updateStarField(dt);
        updatePlayer(dt);
        updateEnemies(dt);
        updateShots(dt);
        drawGame();
        requestAnimationFrame(loop);
      }

      // Init
      makeStarField();
      startNewRun();
      requestAnimationFrame(loop);
    });
  </script>
</body>
</html>
