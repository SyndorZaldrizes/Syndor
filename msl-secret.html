<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MSL: Petriod Protocol – Secret Sector</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="icon" type="image/png" href="logo-1.png" />

  <style>
    body.secret-page {
      background: radial-gradient(circle at top, #020617, #020617 35%, #000 100%);
      color: #e5e7eb;
    }

    .secret-page .section {
      padding-top: 3rem;
      padding-bottom: 3rem;
    }

    .secret-page h1,
    .secret-page h2,
    .secret-page h3 {
      color: #f9fafb;
    }

    .secret-notes {
      background: rgba(15, 23, 42, 0.95);
      border-radius: 1rem;
      padding: 1.25rem 1.5rem;
      border: 1px solid rgba(148, 163, 184, 0.6);
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.9);
      margin-bottom: 1.75rem;
    }

    .secret-notes h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
    }

    .secret-notes ul {
      margin: 0.35rem 0 0.75rem;
      padding-left: 1.1rem;
    }

    .secret-notes li {
      font-size: 0.9rem;
      margin-bottom: 0.2rem;
    }

    .secret-notes p {
      font-size: 0.85rem;
      margin: 0.25rem 0;
    }

    .secret-card {
      background: radial-gradient(circle at top, #020617, #020617 55%, #000 100%);
      border-radius: 1.25rem;
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.95);
      padding: 1.5rem 1.75rem 1.5rem;
      max-width: 1100px;
      margin: 0 auto;
    }

    .secret-card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }

    .secret-card-header h2 {
      font-size: 1.3rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .secret-tag {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      opacity: 0.85;
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
    }

    .secret-shell {
      margin-top: 0.5rem;
      border-radius: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: radial-gradient(circle at top, #020617, #020617 70%, #000 100%);
      padding: 0.75rem;
    }

    .secret-shell canvas {
      display: block;
      margin: 0 auto;
      background: #020617;
      border-radius: 0.75rem;
      max-width: 100%;
      width: 100%;
      height: auto;
    }

    .secret-hud {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 0.6rem;
      font-size: 0.8rem;
      margin-top: 0.5rem;
      color: #e5e7eb;
    }

    .secret-hud span {
      opacity: 0.9;
    }

    .secret-status {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      min-height: 1.2em;
      color: #e5e7eb;
      opacity: 0.9;
    }

    .secret-controls-text {
      margin-top: 0.75rem;
      font-size: 0.8rem;
      opacity: 0.85;
    }

    @media (max-width: 768px) {
      .secret-card {
        padding: 1.25rem 1.1rem;
      }
      .secret-shell {
        padding: 0.5rem;
      }
      .secret-card-header h2 {
        font-size: 1.1rem;
      }
    }
  </style>
</head>

<body class="secret-page">
  <header class="site-header">
    <div class="inner">
      <a href="index.html#hero" class="brand">
        <span class="brand-mark brand-mark-logo">
          <img src="logo-1.png" alt="SMCM MSL logo" />
        </span>
        <span class="brand-text">
          <span class="brand-title">Maryland Student Legislature</span>
          <span class="brand-sub">St. Mary’s College of Maryland Chapter</span>
        </span>
      </a>
      <button class="nav-toggle" id="navToggle" aria-label="Toggle navigation">☰</button>
      <nav class="nav" id="mainNav">
        <a href="index.html#hero">Home</a>
        <a href="index.html#maryland">About MSL</a>
        <a href="index.html#chapter">Our Chapter</a>
        <a href="index.html#journey">Your Journey</a>
        <a href="index.html#documents">Documents</a>
        <a href="executive-board.html">Exec Board</a>
        <a href="resources.html">Resources</a>
        <a href="bulletin.html">Bulletin</a>
        <a href="msl-game.html">Games</a>
        <a href="index.html#gallery">Gallery</a>
        <a href="index.html#contact">Join Us</a>
        <a href="msl-giving.html">GIVING TUESDAY CHAMPIONSHIP</a>
      </nav>
    </div>
  </header>

  <main>
    <section class="section">
      <div class="inner">
        <div class="section-header">
          <p class="eyebrow">Hidden Sector</p>
          <h1>MSL: Petriod Protocol</h1>
          <p class="section-body">
            You found the secret field. Guide the Petriod unit through three sectors, collect data cores,
            pick up an upgrade, open the energy door, and reach the exit portal. Keyboard is required.
          </p>
        </div>

        <!-- Sector notes ABOVE the game -->
        <div class="secret-notes">
          <h2>Sector Notes</h2>
          <ul>
            <li><strong>Alpha:</strong> Tutorial sector – movement, jumps, cores, and the upgrade.</li>
            <li><strong>Beta:</strong> Expanded sector with more platforms and patrolling hostiles.</li>
            <li><strong>Gamma:</strong> Final corridor – enemies, an energy door, and the exit portal.</li>
          </ul>
          <p>
            Controls: <strong>A / D</strong> or <strong>← / →</strong> to move ·
            <strong>W / ↑ / Space</strong> to jump · <strong>J</strong> to fire an energy shot ·
            <strong>R</strong> to restart the run.
          </p>
          <p>
            Pick up the upgrade in Alpha to unlock a double jump that carries into later sectors.
          </p>
        </div>

        <!-- Game card -->
        <article class="card plain-card secret-card">
          <div class="secret-card-header">
            <h2>Petriod Protocol</h2>
            <span class="secret-tag">Simulation Chamber</span>
          </div>
          <p class="small" style="margin-bottom: 0.75rem;">
            Deploy the Petriod core into the field, collect data, and survive long enough to reach the portal.
          </p>

          <div class="secret-shell">
            <canvas id="petriodCanvas" width="900" height="420"></canvas>
            <div class="secret-hud">
              <span id="hud-sector">Sector: Alpha</span>
              <span id="hud-cores">Cores: 0 / 0</span>
              <span id="hud-health">Integrity: ♥♥♥</span>
              <span id="hud-level">Stage: 1 / 3</span>
            </div>
            <div id="hud-status" class="secret-status"></div>
          </div>

          <p class="secret-controls-text">
            Keyboard only: A / D or ← / → to move · W / ↑ / Space to jump · J to fire · R to reset.
          </p>
        </article>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="inner footer-inner">
      <p>© <span id="year"></span> Maryland Student Legislature – St. Mary’s College of Maryland Chapter.</p>
      <p class="small">
        Student-led, nonpartisan, and rooted in Maryland’s civic life. This site is maintained by the SMCM
        Maryland Student Legislature Chapter and is not an official publication of St. Mary’s College of
        Maryland or the State of Maryland.
      </p>
    </div>
  </footer>

  <script src="script.js"></script>

  <!-- Petriod Protocol game logic -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const canvas = document.getElementById("petriodCanvas");
      if (!canvas || !canvas.getContext) return;
      const ctx = canvas.getContext("2d");

      const TILE = 40;
      const COLS = 40;
      const ROWS = 16;
      const WORLD_WIDTH = COLS * TILE;
      const WORLD_HEIGHT = ROWS * TILE;

      // HUD
      const hudSector = document.getElementById("hud-sector");
      const hudCores = document.getElementById("hud-cores");
      const hudHealth = document.getElementById("hud-health");
      const hudLevel = document.getElementById("hud-level");
      const hudStatus = document.getElementById("hud-status");

      // Level layouts
      const LEVELS = [
        {
          name: "Alpha",
          bg: "secret-bg-alpha.jpg",
          map: [
            "........................................",
            "........................................",
            ".......................*................",
            "........................................",
            "........................................",
            "............####........................",
            "............................*...........",
            ".....*..............................S...",
            "############.............###########....",
            "........................................",
            "........................................",
            "........................................",
            "........................................",
            "P....................................E..",
            ".....^^^^^.....^^^^^.....^^^^^..........",
            "########################################"
          ]
        },
        {
          name: "Beta",
          bg: "secret-bg-beta.jpg",
          map: [
            "........................................",
            ".............*......X...................",
            "........................................",
            "..........#######........................",
            ".........................#####..........",
            "........................................",
            "..P..........X......................E...",
            "########################################",
            "........................................",
            "........................................",
            "........................................",
            "........................................",
            "........................................",
            "........................................",
            "........................................",
            "........................................"
          ]
        },
        {
          name: "Gamma",
          bg: "secret-bg-gamma.jpg",
          map: [
            "........................................",
            "...*.................X..................",
            "........................................",
            ".............#####......................",
            ".......................#####............",
            "........................................",
            "........................................",
            "........................................",
            "........................................",
            "........................................",
            "........................................",
            "........................................",
            "........................................",
            "..P..............................D..E...",
            ".....^^^^^.....^^^^^.....^^^^^..........",
            "########################################"
          ]
        }
      ];

      // Make sure all map rows are the right length (safety)
      LEVELS.forEach(level => {
        level.map = level.map.map(row => row.padEnd(COLS, ".").slice(0, COLS));
      });

      // Preload backgrounds (if present)
      const bgImages = LEVELS.map(level => {
        const img = new Image();
        img.src = level.bg;
        return img;
      });

      // Count stars for completion tracking
      let totalStarsAll = 0;
      LEVELS.forEach(level => {
        let count = 0;
        level.map.forEach(row => {
          for (let ch of row) {
            if (ch === "*") count++;
          }
        });
        level.totalStars = count;
        totalStarsAll += count;
      });

      // Game state
      let currentLevelIndex = 0;
      let solids = [];
      let spikes = [];
      let stars = [];
      let enemies = [];
      let suit = null;
      let door = null;
      let portal = null;
      let shots = [];
      let cameraX = 0;

      const player = {
        x: 0,
        y: 0,
        w: 26,
        h: 34,
        vx: 0,
        vy: 0,
        onGround: false,
        facing: 1,
        maxHealth: 3,
        health: 3,
        canDouble: false,
        jumpCount: 0,
        invuln: 0
      };

      let collectedStarsTotal = 0;
      let starField = [];
      let introTime = 0;
      let lastTime = 0;
      let gameOver = false;
      let gameWon = false;
      let shotCooldown = 0;
      let jumpQueued = false;
      let shootQueued = false;

      const keys = {
        left: false,
        right: false
      };

      function makeStarField() {
        starField = [];
        for (let i = 0; i < 70; i++) {
          starField.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            r: Math.random() * 1.8 + 0.4,
            speed: Math.random() * 0.4 + 0.2
          });
        }
      }

      function rectsIntersect(a, b) {
        return (
          a.x < b.x + b.w &&
          a.x + a.w > b.x &&
          a.y < b.y + b.h &&
          a.y + a.h > b.y
        );
      }

      function applyDamage(amount) {
        if (player.invuln > 0 || gameOver || gameWon) return;
        player.health -= amount;
        if (player.health <= 0) {
          player.health = 0;
          gameOver = true;
          hudStatus.textContent = "Shell integrity lost. Press R to redeploy to Alpha.";
        } else {
          player.invuln = 1.0; // seconds
          hudStatus.textContent = "Impact detected. Stabilizing...";
        }
        updateHud();
      }

      function updateHud() {
        const level = LEVELS[currentLevelIndex];
        if (hudSector) {
          hudSector.textContent = "Sector: " + level.name;
        }
        if (hudLevel) {
          hudLevel.textContent = "Stage: " + (currentLevelIndex + 1) + " / " + LEVELS.length;
        }
        if (hudCores) {
          hudCores.textContent = "Cores: " + collectedStarsTotal + " / " + totalStarsAll;
        }
        if (hudHealth) {
          const hearts = "♥".repeat(player.health) + "♡".repeat(player.maxHealth - player.health);
          hudHealth.textContent = "Integrity: " + hearts;
        }
      }

      function buildLevel(index, keepProgress) {
        currentLevelIndex = index;
        const level = LEVELS[index];
        const map = level.map;

        solids = [];
        spikes = [];
        stars = [];
        enemies = [];
        shots = [];
        suit = null;
        door = null;
        portal = null;

        let startX = 80;
        let startY = TILE * (ROWS - 3);

        for (let row = 0; row < ROWS; row++) {
          const line = map[row];
          for (let col = 0; col < COLS; col++) {
            const ch = line[col];
            const x = col * TILE;
            const y = row * TILE;

            switch (ch) {
              case "#":
                solids.push({ x, y, w: TILE, h: TILE });
                break;
              case "^":
                spikes.push({ x, y: y + TILE / 2, w: TILE, h: TILE / 2 });
                break;
              case "*":
                stars.push({
                  x: x + TILE * 0.25,
                  y: y + TILE * 0.25,
                  w: TILE * 0.5,
                  h: TILE * 0.5,
                  collected: false
                });
                break;
              case "P":
                startX = x + TILE * 0.5;
                startY = y + TILE - player.h - 2;
                break;
              case "S":
                suit = { x, y, w: TILE, h: TILE, taken: false };
                break;
              case "D":
                door = { x, y, w: TILE, h: TILE, open: false };
                break;
              case "E":
                portal = { x: x + TILE * 0.5, y: y + TILE * 0.5, r: 18 };
                break;
              case "X":
                enemies.push({
                  x: x + TILE * 0.5,
                  y: y + TILE - 16,
                  w: 24,
                  h: 24,
                  vx: Math.random() < 0.5 ? 1.1 : -1.1,
                  leftBound: x - TILE,
                  rightBound: x + TILE * 2,
                  alive: true
                });
                break;
              default:
                break;
            }
          }
        }

        // Reset player only on fresh run
        if (!keepProgress) {
          player.health = player.maxHealth;
          player.canDouble = false;
          collectedStarsTotal = 0;
        }

        player.x = startX;
        player.y = startY;
        player.vx = 0;
        player.vy = 0;
        player.onGround = false;
        player.jumpCount = 0;
        player.invuln = 0;
        cameraX = Math.max(
          0,
          Math.min(player.x - canvas.width / 2, WORLD_WIDTH - canvas.width)
        );

        if (!keepProgress) {
          hudStatus.textContent = "Deploying unit to " + level.name + " sector. Remain adaptive.";
        } else {
          hudStatus.textContent = "Transitioned to " + level.name + " sector.";
        }
        updateHud();
      }

      function startNewRun() {
        gameOver = false;
        gameWon = false;
        introTime = 0;
        buildLevel(0, false);
        makeStarField();
      }

      // Keyboard input
      window.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        const key = e.key.toLowerCase();

        if (key === "a" || key === "arrowleft") {
          keys.left = true;
        }
        if (key === "d" || key === "arrowright") {
          keys.right = true;
        }
        if (key === "w" || key === "arrowup" || key === " ") {
          e.preventDefault();
          jumpQueued = true;
        }
        if (key === "j") {
          shootQueued = true;
        }
        if (key === "r") {
          startNewRun();
        }
      });

      window.addEventListener("keyup", (e) => {
        const key = e.key.toLowerCase();
        if (key === "a" || key === "arrowleft") {
          keys.left = false;
        }
        if (key === "d" || key === "arrowright") {
          keys.right = false;
        }
      });

      function performJump() {
        if (gameOver || gameWon) return;

        if (player.onGround) {
          player.vy = -11;
          player.onGround = false;
          player.jumpCount = 1;
        } else if (player.canDouble && player.jumpCount < 2) {
          player.vy = -10;
          player.jumpCount++;
        }
      }

      function createShot() {
        if (gameOver || gameWon) return;
        const dir = player.facing >= 0 ? 1 : -1;
        shots.push({
          x: player.x + (dir > 0 ? player.w : -6),
          y: player.y + player.h * 0.35,
          w: 8,
          h: 3,
          vx: dir * 9
        });
      }

      function updateShots(dt) {
        shotCooldown = Math.max(0, shotCooldown - dt);
        const newShots = [];
        for (const s of shots) {
          s.x += s.vx;

          if (s.x < -50 || s.x > WORLD_WIDTH + 50) continue;

          let destroyed = false;

          // Door hit
          if (door && !door.open) {
            if (
              s.x < door.x + door.w &&
              s.x + s.w > door.x &&
              s.y < door.y + door.h &&
              s.y + s.h > door.y
            ) {
              door.open = true;
              hudStatus.textContent = "Energy door unlocked.";
              destroyed = true;
            }
          }

          // Enemy hit
          for (const enemy of enemies) {
            if (!enemy.alive) continue;
            if (
              s.x < enemy.x + enemy.w &&
              s.x + s.w > enemy.x &&
              s.y < enemy.y + enemy.h &&
              s.y + s.h > enemy.y
            ) {
              enemy.alive = false;
              destroyed = true;
              hudStatus.textContent = "Hostile neutralized.";
              break;
            }
          }

          // Solid hit
          if (!destroyed) {
            for (const solid of solids) {
              if (
                s.x < solid.x + solid.w &&
                s.x + s.w > solid.x &&
                s.y < solid.y + solid.h &&
                s.y + s.h > solid.y
              ) {
                destroyed = true;
                break;
              }
            }
          }

          if (!destroyed) newShots.push(s);
        }
        shots = newShots;
      }

      function updateEnemies(dt) {
        for (const e of enemies) {
          if (!e.alive) continue;
          e.x += e.vx;

          if (e.x < e.leftBound) {
            e.x = e.leftBound;
            e.vx *= -1;
          } else if (e.x + e.w > e.rightBound) {
            e.x = e.rightBound - e.w;
            e.vx *= -1;
          }
        }
      }

      function updatePlayer(dt) {
        if (gameOver || gameWon) return;

        const speed = 3.2;
        player.vx = 0;

        if (keys.left) {
          player.vx = -speed;
          player.facing = -1;
        } else if (keys.right) {
          player.vx = speed;
          player.facing = 1;
        }

        if (jumpQueued) {
          performJump();
          jumpQueued = false;
        }

        if (shootQueued && shotCooldown === 0) {
          createShot();
          shotCooldown = 0.22;
          shootQueued = false;
        } else {
          shootQueued = false;
        }

        player.vy += 0.55;
        if (player.vy > 16) player.vy = 16;

        // Horizontal move and collision
        player.x += player.vx;

        const playerRectX = {
          x: player.x,
          y: player.y,
          w: player.w,
          h: player.h
        };

        for (const solid of solids) {
          if (rectsIntersect(playerRectX, solid)) {
            if (player.vx > 0) {
              player.x = solid.x - player.w;
            } else if (player.vx < 0) {
              player.x = solid.x + solid.w;
            }
          }
        }

        if (door && !door.open) {
          const dRect = { x: door.x, y: door.y, w: door.w, h: door.h };
          if (rectsIntersect(playerRectX, dRect)) {
            if (player.vx > 0) {
              player.x = door.x - player.w;
            } else if (player.vx < 0) {
              player.x = door.x + door.w;
            }
          }
        }

        // Vertical move and collision
        player.y += player.vy;
        player.onGround = false;

        const playerRectY = {
          x: player.x,
          y: player.y,
          w: player.w,
          h: player.h
        };

        for (const solid of solids) {
          if (rectsIntersect(playerRectY, solid)) {
            if (player.vy > 0) {
              player.y = solid.y - player.h;
              player.vy = 0;
              player.onGround = true;
              player.jumpCount = 0;
            } else if (player.vy < 0) {
              player.y = solid.y + solid.h;
              player.vy = 0;
            }
          }
        }

        if (door && !door.open) {
          const dRect = { x: door.x, y: door.y, w: door.w, h: door.h };
          if (rectsIntersect(playerRectY, dRect)) {
            if (player.vy > 0) {
              player.y = door.y - player.h;
              player.vy = 0;
              player.onGround = true;
              player.jumpCount = 0;
            } else if (player.vy < 0) {
              player.y = door.y + door.h;
              player.vy = 0;
            }
          }
        }

        // World bounds
        if (player.x < 0) player.x = 0;
        if (player.x + player.w > WORLD_WIDTH) player.x = WORLD_WIDTH - player.w;
        if (player.y > WORLD_HEIGHT + 200) {
          applyDamage(player.maxHealth); // insta fail if you fall off
        }

        // Spikes
        const pRect = { x: player.x, y: player.y, w: player.w, h: player.h };
        for (const s of spikes) {
          if (rectsIntersect(pRect, s)) {
            applyDamage(1);
            break;
          }
        }

        // Enemies
        for (const e of enemies) {
          if (!e.alive) continue;
          const eRect = { x: e.x, y: e.y, w: e.w, h: e.h };
          if (rectsIntersect(pRect, eRect)) {
            applyDamage(1);
            break;
          }
        }

        // Suit pickup
        if (suit && !suit.taken) {
          const sRect = { x: suit.x, y: suit.y, w: suit.w, h: suit.h };
          if (rectsIntersect(pRect, sRect)) {
            suit.taken = true;
            player.canDouble = true;
            hudStatus.textContent = "Mobility upgrade acquired. Double jump online.";
          }
        }

        // Stars
        for (const star of stars) {
          if (star.collected) continue;
          if (rectsIntersect(pRect, star)) {
            star.collected = true;
            collectedStarsTotal++;
            hudStatus.textContent = "Data core secured.";
          }
        }

        // Portal / level transition
        if (portal && !gameOver && !gameWon) {
          const dx = player.x + player.w / 2 - portal.x;
          const dy = player.y + player.h / 2 - portal.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < portal.r + 8) {
            if (currentLevelIndex < LEVELS.length - 1) {
              // Move to next level, keep upgrade and cores
              buildLevel(currentLevelIndex + 1, true);
            } else {
              gameWon = true;
              const fullClear = collectedStarsTotal === totalStarsAll;
              hudStatus.textContent = fullClear
                ? "Protocol complete. All cores recovered."
                : "Protocol complete. Some data cores remain for a perfect run.";
            }
          }
        }

        // Camera follow
        cameraX = player.x - canvas.width / 2;
        if (cameraX < 0) cameraX = 0;
        if (cameraX > WORLD_WIDTH - canvas.width) {
          cameraX = WORLD_WIDTH - canvas.width;
        }

        if (player.invuln > 0) {
          player.invuln -= dt;
          if (player.invuln < 0) player.invuln = 0;
        }

        updateHud();
      }

      function updateStarField(dt) {
        for (const star of starField) {
          star.y += star.speed;
          if (star.y > canvas.height) {
            star.y = -5;
            star.x = Math.random() * canvas.width;
          }
        }
      }

      function drawStarField() {
        for (const star of starField) {
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(248, 250, 252, 0.8)";
          ctx.fill();
        }
      }

      function drawGame() {
        const level = LEVELS[currentLevelIndex];
        const bgImg = bgImages[currentLevelIndex];

        // Background
        if (bgImg && bgImg.complete) {
          ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
        } else {
          const g = ctx.createRadialGradient(
            canvas.width / 2,
            0,
            20,
            canvas.width / 2,
            canvas.height,
            canvas.height
          );
          g.addColorStop(0, "#020617");
          g.addColorStop(1, "#000000");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Starfield
        drawStarField();

        ctx.save();
        ctx.translate(-cameraX, 0);

        // Solids
        ctx.fillStyle = "#0f172a";
        for (const s of solids) {
          ctx.fillRect(s.x, s.y, s.w, s.h);
        }

        // Spikes
        ctx.fillStyle = "#f97316";
        for (const sp of spikes) {
          ctx.beginPath();
          const segments = 3;
          const step = sp.w / segments;
          for (let i = 0; i < segments; i++) {
            const x0 = sp.x + i * step;
            ctx.moveTo(x0, sp.y + sp.h);
            ctx.lineTo(x0 + step / 2, sp.y);
            ctx.lineTo(x0 + step, sp.y + sp.h);
          }
          ctx.closePath();
          ctx.fill();
        }

        // Stars
        for (const star of stars) {
          if (star.collected) continue;
          ctx.fillStyle = "#facc15";
          ctx.beginPath();
          const cx = star.x + star.w / 2;
          const cy = star.y + star.h / 2;
          const r = star.w / 2;
          for (let i = 0; i < 5; i++) {
            const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
            const x = cx + Math.cos(angle) * r;
            const y = cy + Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
        }

        // Suit
        if (suit && !suit.taken) {
          ctx.fillStyle = "#38bdf8";
          ctx.fillRect(suit.x + 4, suit.y + 4, suit.w - 8, suit.h - 8);
        }

        // Door
        if (door) {
          ctx.fillStyle = door.open ? "#4ade80" : "#64748b";
          ctx.fillRect(door.x, door.y, door.w, door.h);
        }

        // Portal
        if (portal) {
          ctx.beginPath();
          ctx.arc(portal.x, portal.y, portal.r, 0, Math.PI * 2);
          const pGrad = ctx.createRadialGradient(
            portal.x,
            portal.y,
            4,
            portal.x,
            portal.y,
            portal.r
          );
          pGrad.addColorStop(0, "#a5b4fc");
          pGrad.addColorStop(1, "#4f46e5");
          ctx.fillStyle = pGrad;
          ctx.fill();
        }

        // Enemies
        for (const e of enemies) {
          if (!e.alive) continue;
          ctx.fillStyle = "#f97373";
          ctx.fillRect(e.x, e.y, e.w, e.h);
        }

        // Player
        ctx.save();
        ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
        if (player.facing < 0) ctx.scale(-1, 1);
        ctx.translate(-player.w / 2, -player.h / 2);

        const baseAlpha = player.invuln > 0 ? 0.6 : 1;
        ctx.globalAlpha = baseAlpha;
        ctx.fillStyle = "#e5e7eb";
        ctx.fillRect(0, 0, player.w, player.h);

        // Helmet
        ctx.fillStyle = "#38bdf8";
        ctx.fillRect(3, 3, player.w - 6, 10);

        // Core symbol
        const img = new Image();
        img.src = "petriod-core.jpg";
        // We won't rely on it drawing every frame; fallback is fine.
        // (If it loads, it'll overlay a small badge.)
        if (img.complete) {
          ctx.drawImage(img, player.w / 2 - 6, player.h / 2 - 6, 12, 12);
        } else {
          ctx.fillStyle = "#0f172a";
          ctx.fillRect(player.w / 2 - 4, player.h / 2 - 4, 8, 8);
        }

        ctx.restore();

        // Shots
        ctx.fillStyle = "#facc15";
        for (const s of shots) {
          ctx.fillRect(s.x, s.y, s.w, s.h);
        }

        ctx.restore();

        // Intro / game over / win overlays
        if (introTime < 3) {
          const alpha = Math.min(1, 3 - introTime);
          ctx.fillStyle = "rgba(15, 23, 42," + (0.7 * alpha) + ")";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "rgba(226, 232, 240," + alpha + ")";
          ctx.textAlign = "center";
          ctx.font = "22px system-ui, -apple-system, sans-serif";
          ctx.fillText("PETRIOD PROTOCOL", canvas.width / 2, canvas.height / 2 - 10);
          ctx.font = "12px system-ui, -apple-system, sans-serif";
          ctx.fillText("Booting hidden field simulator…", canvas.width / 2, canvas.height / 2 + 12);
        } else if (gameOver) {
          ctx.fillStyle = "rgba(15,23,42,0.8)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#f97373";
          ctx.textAlign = "center";
          ctx.font = "18px system-ui, -apple-system, sans-serif";
          ctx.fillText("Simulation failure.", canvas.width / 2, canvas.height / 2 - 6);
          ctx.font = "12px system-ui, -apple-system, sans-serif";
          ctx.fillStyle = "#e5e7eb";
          ctx.fillText("Press R to redeploy from Alpha.", canvas.width / 2, canvas.height / 2 + 12);
        } else if (gameWon) {
          ctx.fillStyle = "rgba(15,23,42,0.78)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#4ade80";
          ctx.textAlign = "center";
          ctx.font = "18px system-ui, -apple-system, sans-serif";
          ctx.fillText("Protocol complete.", canvas.width / 2, canvas.height / 2 - 6);
          ctx.font = "12px system-ui, -apple-system, sans-serif";
          ctx.fillStyle = "#e5e7eb";
          ctx.fillText("Press R to run it again for a cleaner record.", canvas.width / 2, canvas.height / 2 + 12);
        }
      }

      function loop(timestamp) {
        const dt = (timestamp - (lastTime || timestamp)) / 1000;
        lastTime = timestamp;
        introTime += dt;
        updateStarField(dt);
        updatePlayer(dt);
        updateEnemies(dt);
        updateShots(dt);
        drawGame();
        requestAnimationFrame(loop);
      }

      // Init
      makeStarField();
      startNewRun();
      requestAnimationFrame(loop);
    });
  </script>
</body>
</html>
