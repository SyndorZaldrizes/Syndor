<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Petroid Sector – SMCM MSL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="icon" type="image/png" href="logo-1.png" />

  <style>
    body.game-page {
      background: radial-gradient(circle at top, #020617, #000000);
      color: #e5e7eb;
    }

    .game-page h1,
    .game-page h2,
    .game-page h3 {
      color: #f9fafb;
    }

    .game-page .section {
      padding-top: 3rem;
      padding-bottom: 3rem;
    }

    .canvas-shell {
      background: #020617;
      border-radius: 0.75rem;
      padding: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.9);
      overflow: hidden;
    }

    .canvas-shell canvas {
      display: block;
      margin: 0 auto;
      max-width: 100%;
      background: #020617;
      border-radius: 0.5rem;
    }

    #sectorInfo {
      text-align: center;
      margin-bottom: 0.75rem;
      font-size: 0.85rem;
      color: #cbd5f5;
    }

    #gameHud {
      text-align: center;
      margin-top: 0.25rem;
      margin-bottom: 0.25rem;
      font-size: 0.85rem;
      color: #cbd5f5;
    }

    #gameMessage {
      text-align: center;
      margin-top: 0.75rem;
      font-size: 0.85rem;
      min-height: 1.2em;
    }

    /* Intro overlay */
    #introOverlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, #020617, #000000);
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }

    #introOverlay.hidden {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease-out;
    }

    #introCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .intro-message {
      position: relative;
      text-align: center;
      color: #e5e7eb;
      z-index: 2;
      max-width: 580px;
      padding: 1.5rem;
    }

    .intro-message h2 {
      margin-bottom: 0.5rem;
    }

    .intro-message p {
      font-size: 0.9rem;
      opacity: 0.9;
    }

    .intro-message small {
      display: block;
      margin-top: 0.5rem;
      font-size: 0.75rem;
      opacity: 0.8;
    }
  </style>
</head>

<body class="game-page">
  <header class="site-header">
    <div class="inner">
      <a href="index.html#hero" class="brand">
        <span class="brand-mark brand-mark-logo">
          <img src="logo-1.png" alt="SMCM MSL logo" />
        </span>
        <span class="brand-text">
          <span class="brand-title">Maryland Student Legislature</span>
          <span class="brand-sub">St. Mary’s College of Maryland Chapter</span>
        </span>
      </a>
      <button class="nav-toggle" id="navToggle" aria-label="Toggle navigation">☰</button>
      <nav class="nav" id="mainNav">
        <a href="index.html#hero">Home</a>
        <a href="index.html#maryland">About MSL</a>
        <a href="index.html#chapter">Our Chapter</a>
        <a href="index.html#journey">Your Journey</a>
        <a href="index.html#documents">Documents</a>
        <a href="executive-board.html">Exec Board</a>
        <a href="resources.html">Resources</a>
        <a href="bulletin.html">Bulletin</a>
        <a href="msl-game.html">Games</a>
        <a href="index.html#gallery">Gallery</a>
        <a href="index.html#contact">Join Us</a>
        <a href="msl-giving.html">GIVING TUESDAY CHAMPIONSHIP</a>
      </nav>
    </div>
  </header>

  <main>
    <section class="section">
      <div class="inner">
        <div class="section-header center">
          <p class="eyebrow">Hidden Level</p>
          <h1>Petroid Sector Run</h1>
          <p class="section-body">
            Move through the sector, avoid hazards, collect all stars, and reach the portal.
            The field is split into three regions – Alpha, Beta, and Gamma – with different
            backgrounds as you progress.
          </p>
        </div>

        <!-- Sector notes / controls -->
        <div id="sectorInfo" class="small">
          <strong>Controls:</strong> A / D (or ← / →) to move · W / ↑ / Space to jump · J to fire a shot · R to respawn.<br />
          Collect every star, pick up the suit upgrade, and blast open energy doors to reach the portal.
        </div>

        <!-- HUD above canvas -->
        <p id="gameHud" class="small"></p>

        <div class="canvas-shell">
          <!-- Smaller viewport; world scrolls in both directions -->
          <canvas id="metroidCanvas" width="832" height="320"></canvas>
        </div>

        <p id="gameMessage" class="small"></p>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="inner footer-inner">
      <p>© <span id="year"></span> Maryland Student Legislature – St. Mary’s College of Maryland Chapter.</p>
      <p class="small">
        Student-led, nonpartisan, and rooted in Maryland’s civic life. This site is maintained by the SMCM
        Maryland Student Legislature Chapter and is not an official publication of St. Mary’s College of
        Maryland or the State of Maryland.
      </p>
    </div>
  </footer>

  <!-- Galaxy intro overlay -->
  <div id="introOverlay">
    <canvas id="introCanvas"></canvas>
    <div class="intro-message">
      <h2>Petroid Sector: Online</h2>
      <p>
        Stars scattered. Fields unstable. Navigate Alpha, Beta, and Gamma, gather the last signal fragments,
        and bring the portal back online.
      </p>
      <small>Press any key or click to begin.</small>
    </div>
  </div>

  <script src="script.js"></script>

  <!-- Page-specific JS -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      /* ==========================
         GALAXY INTRO STARFIELD
      =========================== */
      (function () {
        const overlay = document.getElementById("introOverlay");
        const canvas = document.getElementById("introCanvas");
        if (!overlay || !canvas) return;
        const ctx = canvas.getContext("2d");

        function resizeIntro() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }
        resizeIntro();
        window.addEventListener("resize", resizeIntro);

        const stars = [];
        const STAR_COUNT = 220;
        for (let i = 0; i < STAR_COUNT; i++) {
          stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            z: Math.random() * 1.8 + 0.4,
            r: Math.random() * 1.6 + 0.4
          });
        }

        let startTime = performance.now();
        let running = true;

        function drawIntroFrame(time) {
          if (!running) return;
          const dt = (time - startTime) / 1000;

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#020617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Nebula glow
          const g1 = ctx.createRadialGradient(
            canvas.width * 0.3,
            canvas.height * 0.2,
            0,
            canvas.width * 0.3,
            canvas.height * 0.2,
            canvas.width * 0.7
          );
          g1.addColorStop(0, "rgba(59, 130, 246, 0.35)");
          g1.addColorStop(0.4, "rgba(129, 140, 248, 0.18)");
          g1.addColorStop(1, "rgba(15, 23, 42, 0)");
          ctx.fillStyle = g1;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          const g2 = ctx.createRadialGradient(
            canvas.width * 0.75,
            canvas.height * 0.6,
            0,
            canvas.width * 0.75,
            canvas.height * 0.6,
            canvas.width * 0.6
          );
          g2.addColorStop(0, "rgba(236, 72, 153, 0.25)");
          g2.addColorStop(0.4, "rgba(59, 130, 246, 0.12)");
          g2.addColorStop(1, "rgba(15, 23, 42, 0)");
          ctx.fillStyle = g2;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Stars drifting down
          stars.forEach(star => {
            star.y += star.z * 35 * (1 / 60);
            if (star.y > canvas.height) {
              star.y = 0;
              star.x = Math.random() * canvas.width;
            }
            const twinkle = 0.6 + 0.4 * Math.sin((time / 300) + star.x * 0.005);
            const alpha = (0.25 + 0.55 * star.z) * twinkle;
            ctx.fillStyle = "rgba(248, 250, 252," + alpha.toFixed(2) + ")";
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
            ctx.fill();
          });

          if (dt >= 6) {
            closeIntro();
            return;
          }
          requestAnimationFrame(drawIntroFrame);
        }

        function closeIntro() {
          running = false;
          overlay.classList.add("hidden");
        }

        overlay.addEventListener("click", closeIntro);
        window.addEventListener("keydown", closeIntro);

        requestAnimationFrame(drawIntroFrame);
      })();

      /* ==========================
         PETROID PLATFORMER
      =========================== */
      (function () {
        const canvas = document.getElementById("metroidCanvas");
        const hudEl = document.getElementById("gameHud");
        const messageEl = document.getElementById("gameMessage");
        if (!canvas || !hudEl || !messageEl) return;
        const ctx = canvas.getContext("2d");

        const TILE = 32;

        // Base layout (original structure, no horizontal stretch)
        const rawRows = [
          "................................................................................",
          "................................................................................",
          "................................................................................",
          "..................####....................####..................................",
          ".................#....#..................#....#.................................",
          "...............##......##..............##......##.............***..............",
          "................................................................................",
          "...P......***....................####...................####....................",
          "###########^^^^#########################^^^^#####################^^^^###########",
          "................................................................................",
          ".......................***....................####..............................",
          "..............####.....................***..#....#..............................",
          ".............#....#...........####..........#....#.............####.............",
          ".........***.#....#.........##....##....E..##....##...........#....#............",
          "#########^^^^######^^^^^^^^^######^^^^^^^^^^^^^^######^^^^^^^^######^^^^^^^^####",
          "................................................................................",
          "................................................................................"
        ];

        let spawnRaw = { x: 2, y: 7 };

        let rows = rawRows.map((rowStr, y) => {
          const arr = rowStr.split("");
          arr.forEach((ch, x) => {
            if (ch === "P") {
              spawnRaw = { x, y };
              arr[x] = ".";
            }
          });
          return arr;
        });

        const ROWS = rows.length;
        const COLS = rows[0].length;
        const worldWidth = COLS * TILE;
        const worldHeight = ROWS * TILE;

        function getTile(tx, ty) {
          if (ty < 0 || ty >= ROWS || tx < 0) return ".";
          const row = rows[ty];
          if (!row || tx >= row.length) return ".";
          return row[tx] || ".";
        }

        function setTile(tx, ty, ch) {
          if (ty < 0 || ty >= ROWS || tx < 0) return;
          const row = rows[ty];
          if (!row || tx >= row.length) return;
          row[tx] = ch;
        }

        function isSolid(ch) {
          // Doors and suit platforms count as solid
          return ch === "#" || ch === "D" || ch === "S";
        }
        function isHazard(ch) {
          return ch === "^";
        }
        function isPortal(ch) {
          return ch === "E";
        }
        function isStar(ch) {
          return ch === "*";
        }

        // Add a suit upgrade and a door into the existing layout
        // Suit on an early platform
        setTile(17, 4, "S");
        // One energy door mid-level
        setTile(40, 8, "D");

        // Count stars
        let totalStars = 0;
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            if (rows[y][x] === "*") totalStars++;
          }
        }

        // Spawn position (in tiles)
        const spawn = {
          x: spawnRaw.x + 0.5,
          y: spawnRaw.y + 0.5
        };

        let collectedStars = 0;
        let sectorName = "Alpha";

        function computeSectorName(px) {
          const clamped = Math.max(0, Math.min(worldWidth, px));
          const unit = worldWidth / 6; // alpha:1, beta:2, gamma:3
          if (clamped < unit) return "Alpha";
          if (clamped < unit * 3) return "Beta";
          return "Gamma";
        }

        const player = {
          x: spawn.x * TILE,
          y: spawn.y * TILE,
          vx: 0,
          vy: 0,
          onGround: false,
          facing: 1
        };

        let keys = {
          left: false,
          right: false,
          up: false,
          down: false,
          jump: false
        };

        const GRAVITY = 1400;
        const MOVE_ACCEL = 2500;
        const MAX_SPEED = 260;
        const BASE_JUMP_VELOCITY = -520;
        const SUIT_JUMP_VELOCITY = -720;
        let jumpVelocity = BASE_JUMP_VELOCITY;
        const FRICTION = 0.9;

        const PLAYER_W = 22;
        const PLAYER_H = 30;

        let hasSuit = false;
        let spinAngle = 0;

        // Camera
        let cameraX = 0;
        let cameraY = 0;

        let gameWon = false;

        // Blaster / bullets
        const bullets = [];
        const BULLET_SPEED = 460;
        const BULLET_LIFETIME = 1.2;

        // Petroid sprite (optional)
        const metroidSprite = new Image();
        metroidSprite.src = "petroid-core.png"; // optional; fallback is glow orb

        // Sector backgrounds (optional)
        const sectorBackgrounds = {
          Alpha: new Image(),
          Beta: new Image(),
          Gamma: new Image()
        };
        sectorBackgrounds.Alpha.src = "secret-bg-alpha.jpg";
        sectorBackgrounds.Beta.src = "secret-bg-beta.jpg";
        sectorBackgrounds.Gamma.src = "secret-bg-gamma.jpg";

        // HUD / messages
        let lastStatus = "Online";

        function updateHud(statusText) {
          if (statusText) lastStatus = statusText;
          hudEl.textContent =
            "Stars: " +
            collectedStars +
            " / " +
            totalStars +
            " · Sector: " +
            sectorName +
            " · Status: " +
            (gameWon ? "Beacon online" : lastStatus);
        }

        function showMessage(text) {
          messageEl.textContent = text || "";
        }

        function respawn() {
          player.x = spawn.x * TILE;
          player.y = spawn.y * TILE;
          player.vx = 0;
          player.vy = 0;
          player.onGround = false;
          gameWon = false;
          // You keep the suit if you unlocked it
          showMessage("Respawned at last safe node.");
          updateHud("Online");
        }

        updateHud();
        showMessage("Collect stars, find the suit, and blast doors to reach the portal.");

        // Input
        window.addEventListener("keydown", (e) => {
          const key = e.key.toLowerCase();

          if (["arrowleft", "a"].includes(key)) {
            keys.left = true;
            e.preventDefault();
          }
          if (["arrowright", "d"].includes(key)) {
            keys.right = true;
            e.preventDefault();
          }
          if (["arrowup", "w"].includes(key)) {
            keys.up = true;
            keys.jump = true;
            e.preventDefault();
          }
          if (key === " ") {
            keys.jump = true;
            e.preventDefault();
          }
          if (["arrowdown", "s"].includes(key)) {
            keys.down = true;
          }
          if (key === "r") {
            respawn();
            e.preventDefault();
          }
          if (key === "j") {
            fireBullet();
            e.preventDefault();
          }
        });

        window.addEventListener("keyup", (e) => {
          const key = e.key.toLowerCase();

          if (["arrowleft", "a"].includes(key)) {
            keys.left = false;
          }
          if (["arrowright", "d"].includes(key)) {
            keys.right = false;
          }
          if (["arrowup", "w"].includes(key)) {
            keys.up = false;
            keys.jump = false;
          }
          if (key === " ") {
            keys.jump = false;
          }
          if (["arrowdown", "s"].includes(key)) {
            keys.down = false;
          }
        });

        /* ---------- BULLETS ---------- */
        function fireBullet() {
          if (bullets.length > 6) return;

          let dirX = 0;
          let dirY = 0;

          // Simple aiming: if only up/down pressed, shoot vertical, else horizontal
          if (keys.up && !keys.down && !keys.left && !keys.right) {
            dirY = -1;
          } else if (keys.down && !keys.up && !keys.left && !keys.right) {
            dirY = 1;
          } else {
            dirX = player.facing || 1;
          }

          if (dirX === 0 && dirY === 0) {
            dirX = player.facing || 1;
          }

          const mag = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
          dirX /= mag;
          dirY /= mag;

          const startX = player.x + dirX * (PLAYER_W / 2 + 8);
          const startY = player.y - 4 + dirY * 4;

          bullets.push({
            x: startX,
            y: startY,
            vx: dirX * BULLET_SPEED,
            vy: dirY * BULLET_SPEED,
            life: BULLET_LIFETIME
          });
        }

        function updateBullets(dt) {
          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            b.life -= dt;

            if (b.life <= 0 || b.x < 0 || b.x > worldWidth || b.y < 0 || b.y > worldHeight) {
              bullets.splice(i, 1);
              continue;
            }

            const tx = Math.floor(b.x / TILE);
            const ty = Math.floor(b.y / TILE);
            const ch = getTile(tx, ty);

            if (ch === "D") {
              // Open door
              setTile(tx, ty, ".");
              bullets.splice(i, 1);
              showMessage("Energy door opened.");
              updateHud("Path cleared");
              continue;
            }

            if (isSolid(ch) || isHazard(ch)) {
              bullets.splice(i, 1);
              continue;
            }
          }
        }

        function drawBullets() {
          ctx.save();
          ctx.translate(-cameraX, -cameraY);
          bullets.forEach(b => {
            ctx.fillStyle = "#f97316";
            ctx.beginPath();
            ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = "rgba(250, 204, 21, 0.7)";
            ctx.beginPath();
            ctx.arc(b.x, b.y, 6, 0, Math.PI * 2);
            ctx.stroke();
          });
          ctx.restore();
        }

        /* ---------- COLLISIONS ---------- */
        function rectVsTileCollision(x, y, w, h, vx, vy, dt) {
          let newX = x + vx * dt;
          let newY = y + vy * dt;
          let onGround = false;

          // Horizontal
          if (vx !== 0) {
            const dirX = Math.sign(vx);
            const aheadX = dirX > 0 ? newX + w / 2 : newX - w / 2;
            const topY = newY - h / 2 + 2;
            const bottomY = newY + h / 2 - 2;

            const tileTop = Math.floor(topY / TILE);
            const tileBottom = Math.floor(bottomY / TILE);
            const tileX = Math.floor(aheadX / TILE);

            for (let ty = tileTop; ty <= tileBottom; ty++) {
              const ch = getTile(tileX, ty);
              if (isSolid(ch)) {
                if (dirX > 0) {
                  newX = tileX * TILE - w / 2;
                } else {
                  newX = (tileX + 1) * TILE + w / 2;
                }
                vx = 0;
                break;
              }
            }
          }

          // Vertical
          if (vy !== 0) {
            const dirY = Math.sign(vy);
            const aheadY = dirY > 0 ? newY + h / 2 : newY - h / 2;
            const leftX = newX - w / 2 + 4;
            const rightX = newX + w / 2 - 4;

            const tileLeft = Math.floor(leftX / TILE);
            const tileRight = Math.floor(rightX / TILE);
            const tileY = Math.floor(aheadY / TILE);

            for (let tx = tileLeft; tx <= tileRight; tx++) {
              const ch = getTile(tx, tileY);
              if (isSolid(ch)) {
                if (dirY > 0) {
                  newY = tileY * TILE - h / 2;
                  onGround = true;
                } else {
                  newY = (tileY + 1) * TILE + h / 2;
                }
                vy = 0;
                break;
              }
            }
          }

          return { x: newX, y: newY, vx, vy, onGround };
        }

        function checkHazardsStarsSuitPortal(px, py, w, h) {
          let hazardHit = false;
          let portalHit = false;

          const left = Math.floor((px - w / 2) / TILE);
          const right = Math.floor((px + w / 2) / TILE);
          const top = Math.floor((py - h / 2) / TILE);
          const bottom = Math.floor((py + h / 2) / TILE);

          const playerRect = {
            x: px - w / 2,
            y: py - h / 2,
            w: w,
            h: h
          };

          function rectsOverlap(a, b) {
            return !(
              a.x + a.w <= b.x ||
              a.x >= b.x + b.w ||
              a.y + a.h <= b.y ||
              a.y >= b.y + b.h
            );
          }

          for (let ty = top; ty <= bottom; ty++) {
            for (let tx = left; tx <= right; tx++) {
              const ch = getTile(tx, ty);
              const tileX = tx * TILE;
              const tileY = ty * TILE;

              if (isStar(ch)) {
                const starRect = {
                  x: tileX + TILE * 0.2,
                  y: tileY + TILE * 0.2,
                  w: TILE * 0.6,
                  h: TILE * 0.6
                };
                if (rectsOverlap(playerRect, starRect)) {
                  setTile(tx, ty, ".");
                  collectedStars++;
                  updateHud("Quorum strengthened");
                  showMessage("Star collected. Current quorum: " + collectedStars + ".");
                }
              }

              if (isHazard(ch)) {
                const hazardRect = {
                  x: tileX + TILE * 0.15,
                  y: tileY + TILE * 0.4,
                  w: TILE * 0.7,
                  h: TILE * 0.55
                };
                if (rectsOverlap(playerRect, hazardRect)) {
                  hazardHit = true;
                }
              }

              if (ch === "S") {
                const suitRect = {
                  x: tileX + TILE * 0.2,
                  y: tileY + TILE * 0.05,
                  w: TILE * 0.6,
                  h: TILE * 0.9
                };
                if (!hasSuit && rectsOverlap(playerRect, suitRect)) {
                  hasSuit = true;
                  jumpVelocity = SUIT_JUMP_VELOCITY;
                  setTile(tx, ty, "#"); // leave a platform behind
                  showMessage("Suit online. Jumps enhanced; spin jump unlocked.");
                  updateHud("Suit synced");
                }
              }

              if (isPortal(ch)) {
                const portalRect = {
                  x: tileX + TILE * 0.1,
                  y: tileY + TILE * 0.1,
                  w: TILE * 0.8,
                  h: TILE * 0.8
                };
                if (rectsOverlap(playerRect, portalRect)) {
                  portalHit = true;
                }
              }
            }
          }

          return { hazardHit, portalHit };
        }

        function updateCamera() {
          const targetX = player.x - canvas.width / 2;
          const targetY = player.y - canvas.height / 2;
          const maxCamX = Math.max(0, worldWidth - canvas.width);
          const maxCamY = Math.max(0, worldHeight - canvas.height);

          cameraX = Math.max(0, Math.min(maxCamX, targetX));
          cameraY = Math.max(0, Math.min(maxCamY, targetY));
        }

        function drawBackground() {
          const bg = sectorBackgrounds[sectorName];
          if (bg && bg.complete && bg.naturalWidth > 0) {
            const scale = Math.max(
              canvas.width / bg.naturalWidth,
              canvas.height / bg.naturalHeight
            );
            const drawW = bg.naturalWidth * scale;
            const drawH = bg.naturalHeight * scale;
            const dx = (canvas.width - drawW) / 2;
            const dy = (canvas.height - drawH) / 2;
            ctx.drawImage(bg, dx, dy, drawW, drawH);
          } else {
            let topColor = "#020617";
            let bottomColor = "#020617";
            if (sectorName === "Alpha") {
              topColor = "#020617";
              bottomColor = "#020617";
            } else if (sectorName === "Beta") {
              topColor = "#0b1120";
              bottomColor = "#020617";
            } else {
              topColor = "#020617";
              bottomColor = "#000000";
            }
            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, topColor);
            grad.addColorStop(1, bottomColor);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }

          // Dim the background so tiles/pop stand out
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawWorld() {
          drawBackground();

          const startCol = Math.floor(cameraX / TILE);
          const endCol = Math.ceil((cameraX + canvas.width) / TILE);
          const startRow = Math.floor(cameraY / TILE);
          const endRow = Math.ceil((cameraY + canvas.height) / TILE);

          for (let y = startRow; y <= endRow; y++) {
            if (y < 0 || y >= ROWS) continue;
            for (let x = startCol; x <= endCol; x++) {
              if (x < 0 || x >= COLS) continue;
              const ch = getTile(x, y);
              if (ch === ".") continue;

              const screenX = x * TILE - cameraX;
              const screenY = y * TILE - cameraY;

              if (ch === "#") {
                ctx.fillStyle = "#111827";
                ctx.fillRect(screenX, screenY, TILE, TILE);
                ctx.strokeStyle = "#1f2937";
                ctx.strokeRect(screenX, screenY, TILE, TILE);
              } else if (ch === "D") {
                ctx.fillStyle = "#0f172a";
                ctx.fillRect(screenX + 6, screenY, TILE - 12, TILE);
                ctx.strokeStyle = "#22d3ee";
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX + 6, screenY, TILE - 12, TILE);
              } else if (ch === "S") {
                ctx.fillStyle = "#38bdf8";
                ctx.fillRect(screenX + 6, screenY + 6, TILE - 12, TILE - 12);
                ctx.strokeStyle = "#facc15";
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX + 6, screenY + 6, TILE - 12, TILE - 12);
              } else if (isHazard(ch)) {
                ctx.fillStyle = "#b91c1c";
                ctx.beginPath();
                ctx.moveTo(screenX, screenY + TILE);
                ctx.lineTo(screenX + TILE / 2, screenY + TILE * 0.3);
                ctx.lineTo(screenX + TILE, screenY + TILE);
                ctx.closePath();
                ctx.fill();
              } else if (isStar(ch)) {
                ctx.fillStyle = "#facc15";
                ctx.beginPath();
                const cx = screenX + TILE / 2;
                const cy = screenY + TILE / 2;
                ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#f97316";
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
              } else if (isPortal(ch)) {
                const cx = screenX + TILE / 2;
                const cy = screenY + TILE / 2;
                const r = TILE * 0.4;
                const inner = r * 0.55;
                const alpha = 0.75;
                ctx.beginPath();
                ctx.strokeStyle = "rgba(129, 140, 248," + alpha + ")";
                ctx.lineWidth = 3;
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.strokeStyle = "rgba(56, 189, 248," + alpha + ")";
                ctx.arc(cx, cy, inner, 0, Math.PI * 2);
                ctx.stroke();
              }
            }
          }

          // Little parallax sparkles
          ctx.save();
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = "#9ca3af";
          for (let i = 0; i < 40; i++) {
            const sx = ((i * 137 + cameraX * 0.3) % canvas.width);
            const sy = (i * 59 + cameraY * 0.2) % canvas.height;
            ctx.fillRect(sx, sy, 2, 2);
          }
          ctx.restore();
        }

        function drawPlayer() {
          const screenX = player.x - cameraX;
          const screenY = player.y - cameraY;
          const sprite = metroidSprite;
          const spriteReady = sprite && sprite.complete && sprite.naturalWidth > 0;

          ctx.save();
          ctx.translate(screenX, screenY);

          if (player.facing < 0) {
            ctx.scale(-1, 1);
          }

          if (hasSuit && !player.onGround && player.vy < 0) {
            spinAngle += 0.15;
          } else {
            spinAngle *= 0.9;
          }

          if (hasSuit && !player.onGround) {
            ctx.rotate(spinAngle);
          }

          if (spriteReady) {
            const scale = 0.7;
            const drawW = sprite.width * scale;
            const drawH = sprite.height * scale;
            ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
          } else {
            const radius = 14;
            const grad = ctx.createRadialGradient(-4, -5, 2, 0, 0, radius);
            grad.addColorStop(0, hasSuit ? "#a855f7" : "#facc15");
            grad.addColorStop(0.5, hasSuit ? "#22c55e" : "#f97316");
            grad.addColorStop(1, "#111827");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
        }

        // Game loop
        let lastTime = performance.now();

        function step(timestamp) {
          const dt = Math.min((timestamp - lastTime) / 1000, 0.03);
          lastTime = timestamp;

          update(dt);
          render();
          requestAnimationFrame(step);
        }

        function update(dt) {
          if (gameWon) {
            player.vy = Math.sin(performance.now() / 500) * 10;
          } else {
            let moveDir = 0;
            if (keys.left) moveDir -= 1;
            if (keys.right) moveDir += 1;

            if (moveDir !== 0) {
              player.facing = moveDir;
              player.vx += moveDir * MOVE_ACCEL * dt;
            } else {
              player.vx *= FRICTION;
            }

            if (player.vx > MAX_SPEED) player.vx = MAX_SPEED;
            if (player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;

            if (keys.jump && player.onGround) {
              player.vy = jumpVelocity;
              player.onGround = false;
            }

            player.vy += GRAVITY * dt;

            const res = rectVsTileCollision(
              player.x,
              player.y,
              PLAYER_W,
              PLAYER_H,
              player.vx,
              player.vy,
              dt
            );
            player.x = res.x;
            player.y = res.y;
            player.vx = res.vx;
            player.vy = res.vy;
            player.onGround = res.onGround;

            const checks = checkHazardsStarsSuitPortal(
              player.x,
              player.y,
              PLAYER_W,
              PLAYER_H
            );

            if (checks.hazardHit && !gameWon) {
              showMessage("Hazard contact. Respawning…");
              respawn();
            }

            if (checks.portalHit && collectedStars >= totalStars && !gameWon) {
              gameWon = true;
              showMessage("Portal reached with full quorum. Sector stabilized.");
              updateHud("Beacon online");
            } else if (checks.portalHit && !gameWon) {
              showMessage(
                "Portal detected, but quorum is low. Stars: " +
                  collectedStars +
                  " / " +
                  totalStars +
                  "."
              );
            }
          }

          updateBullets(dt);

          sectorName = computeSectorName(player.x);
          updateCamera();
          updateHud();
        }

        function render() {
          drawWorld();
          drawBullets();
          drawPlayer();
        }

        respawn();
        requestAnimationFrame(step);
      })();
    });
  </script>
</body>
</html>
